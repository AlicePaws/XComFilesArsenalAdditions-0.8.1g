items:
#Uses alphabetical order for resistances stacking, names should go worst to best; unique Index should follow that
#Unique index slots do not stack with each other, alphabetically first is used
#Slots
# ITEM_RESIST_SLOT_INDEX: 1 - Back
# ITEM_RESIST_SLOT_INDEX: 2 - Belt
# ITEM_RESIST_SLOT_INDEX: 3 - ???
# ITEM_RESIST_SLOT_INDEX: 4 - ???
# ITEM_RESIST_SLOT_INDEX: 5 - ???
# ITEM_RESIST_SLOT_INDEX: 6 - ???
# ITEM_RESIST_SLOT_INDEX: 7 - ???
# ITEM_RESIST_SLOT_INDEX: 8 - ???
# ITEM_RESIST_SLOT_INDEX: 9 - ???
  - type: STR_ALLOY_SHOTGUN
    tags:
      ALLOW_AMMO_TO_RESPRITE: 1
      NEW_BIGOB_FOR_WEAPON: 208 #changes always, original
      CURRENT_MOD_OFFSET: current
  - type: STR_ALLOY_SHOTGUN_SHARDS
    tags:
      NEW_BIGOB_FOR_WEAPON: 208 #changes always, original
      CURRENT_MOD_OFFSET: current
  - type: STR_ALLOY_SHOTGUN_TRACITE_SHARDS
    tags:
      NEW_BIGOB_FOR_WEAPON: 578 #changes always, tracite
      CURRENT_MOD_OFFSET: current
  - type: STR_WP_7_62_CLIP
    tags:
      GENERIC_AMMO: 1
      CURRENT_MOD_OFFSET: current
      NEW_BIGOB_FOR_SLOT_0: 577 #bigob always changes, no other sprite change
      WEAPON_SLOT_0: 566 #STR_RPK
  - type: STR_WP_7_62_CLIP_AP
    tags:
      GENERIC_AMMO_AP: 1
      CURRENT_MOD_OFFSET: current
      NEW_BIGOB_FOR_SLOT_0: 577 #bigob always changes, no other sprite change
      WEAPON_SLOT_0: 566 #STR_RPK
  - type: STR_RPK
    tags:
      ALLOW_AMMO_TO_RESPRITE: 1
      NEW_BIGOB_FOR_WEAPON: 576 #changes always, empty
      NEW_FLOOROB_FOR_WEAPON: 445 #changes once, empty
      NEW_HANDOB_FOR_WEAPON: 2752 #changes once, empty
      CURRENT_MOD_OFFSET: current
  - type: STR_RPK_CLIP
    tags:
      NEW_BIGOB_FOR_WEAPON: 566 #changes always, original
      NEW_FLOOROB_FOR_WEAPON: 443 #changes once, original
      NEW_HANDOB_FOR_WEAPON: 2736 #changes once, original
      CURRENT_MOD_OFFSET: current
  - type: STR_RPK_DRUM
    tags:
      NEW_BIGOB_FOR_WEAPON: 575 #changes always, big cilp/drum
      NEW_FLOOROB_FOR_WEAPON: 444 #changes once, big clip/drum
      NEW_HANDOB_FOR_WEAPON: 2744 #changes once, big clip/drum
      CURRENT_MOD_OFFSET: current
  - type: STR_RIOT_WIELDABLE_SHIELD
    tags:
      ITEM_IS_SHIELD: 1
      CURRENT_MOD_OFFSET: current
      BIGOB_FOR_PRIMED: 579
      HANDOB_FOR_PRIMED: 2760
      BIGOB_FOR_BROKEN: 580
      HANDOB_FOR_BROKEN: 2768
      FLOOROB_FOR_BROKEN: 446
      SHIELD_ARMOR: 10 #8
      SHIELD_DURABILITY: 50
      SHIELD_MULTIPLIER: 200
      SHIELD_AIMING_PENALTY: 8
      SHIELD_KINETIC_RT: 75
      SHIELD_INCENDIARY_RT: 120
      SHIELD_MAX_DMG: 35 #25 + 10? or just 25?
  - type: STR_XENO_COMBAT_WIELDABLE_SHIELD
    tags:
      ITEM_IS_SHIELD: 1
      CURRENT_MOD_OFFSET: current
      BIGOB_FOR_PRIMED: 581
      HANDOB_FOR_PRIMED: 2776
      BIGOB_FOR_BROKEN: 580
      HANDOB_FOR_BROKEN: 2768
      FLOOROB_FOR_BROKEN: 446
      SHIELD_ARMOR: 12 #10
      SHIELD_DURABILITY: 75
      SHIELD_MULTIPLIER: 200
      SHIELD_AIMING_PENALTY: 10
      SHIELD_KINETIC_RT: 70
      SHIELD_INCENDIARY_RT: 120
      SHIELD_MAX_DMG: 38 #28 + 10? or just 28?
  - type: STR_XENO_ALLOY_WIELDABLE_SHIELD
    tags:
      ITEM_IS_SHIELD: 1
      CURRENT_MOD_OFFSET: current
      BIGOB_FOR_PRIMED: 582
      HANDOB_FOR_PRIMED: 2784
      BIGOB_FOR_BROKEN: 580
      HANDOB_FOR_BROKEN: 2768
      FLOOROB_FOR_BROKEN: 446
      SHIELD_ARMOR: 14 #12
      SHIELD_DURABILITY: 90
      SHIELD_MULTIPLIER: 200
      SHIELD_AIMING_PENALTY: 10
      SHIELD_KINETIC_RT: 80
      SHIELD_LASER_RT: 80
      SHIELD_ELECTRIC_RT: 80
      SHIELD_MAX_DMG: 54 #44 + 10? or just 44?
  - type: STR_ASSAULT_WIELDABLE_SHIELD
    tags:
      ITEM_IS_SHIELD: 1
      CURRENT_MOD_OFFSET: current
      BIGOB_FOR_PRIMED: 583
      HANDOB_FOR_PRIMED: 2792
      BIGOB_FOR_BROKEN: 584
      HANDOB_FOR_BROKEN: 2768
      FLOOROB_FOR_BROKEN: 446
      SHIELD_ARMOR: 20 #15
      SHIELD_DURABILITY: 100
      SHIELD_MULTIPLIER: 300
      SHIELD_AIMING_PENALTY: 15
      SHIELD_INCENDIARY_RT: 20
      SHIELD_CONCUSSIVE_RT: 90
      SHIELD_ELECTRIC_RT: 35
      SHIELD_WARP_RT: 85
      SHIELD_MAX_DMG: 84 #70 + 14? or just 70?
  - type: STR_STORMTROOPER_WIELDABLE_SHIELD
    tags:
      ITEM_IS_SHIELD: 1
      CURRENT_MOD_OFFSET: current
      BIGOB_FOR_PRIMED: 585
      HANDOB_FOR_PRIMED: 2800
      BIGOB_FOR_BROKEN: 586
      HANDOB_FOR_BROKEN: 2768
      FLOOROB_FOR_BROKEN: 446
      SHIELD_ARMOR: 18 #15
      SHIELD_DURABILITY: 100
      SHIELD_MULTIPLIER: 200
      SHIELD_AIMING_PENALTY: 12
      SHIELD_INCENDIARY_RT: 15
      SHIELD_LASER_RT: 120
      SHIELD_ELECTRIC_RT: 20
      SHIELD_MAX_DMG: 92 #80 + 12? or just 80?
  - type: STR_UNARMED_THE_ONE
    tags:
      ITEM_THE_ONE: 1
      YTAG_DAMAGE_RETURNED_AS_HP: 50
      YTAG_DAMAGE_RETURNED_RESIST_TYPE: 12
  - type: STR_GASMASK
    tags:
      ITEM_GASMASK: 1
      ITEM_GASMASK_PROTECTION: 100
      ITEM_REACTION_PENALTY: 10
      ITEM_FIRING_AIM_PENALTY: 10
      ITEM_THROWING_AIM_PENALTY: 10
      ITEM_MELEE_PENALTY: 4
      ITEM_RESIST_SLOT_INDEX: 2
      GASMASK_DURABILITY: 100
  - type: STR_TINTED_GASMASK
    tags:
      ITEM_TINTED_GASMASK: 1
      ITEM_GASMASK_PROTECTION: 100
      ITEM_REACTION_PENALTY: 10
      ITEM_FIRING_AIM_PENALTY: 15
      ITEM_THROWING_AIM_PENALTY: 15
      ITEM_MELEE_PENALTY: 6
      ITEM_RESIST_SLOT_INDEX: 2
      GASMASK_DURABILITY: 100
  - type: STR_ALLOY_GASMASK
    tags:
      ITEM_ALLOY_GASMASK: 1
      ITEM_GASMASK_PROTECTION: 200
      ITEM_REACTION_PENALTY: 10
      ITEM_FIRING_AIM_PENALTY: 10
      ITEM_THROWING_AIM_PENALTY: 10
      ITEM_MELEE_PENALTY: 8
      ITEM_RESIST_SLOT_INDEX: 2
      GASMASK_DURABILITY: 200
  - type: STR_RIOT_STAB_VEST
    tags:
      ITEM_RIOT_STAB_VEST: 1
      ITEM_RESIST_SLOT_INDEX: 1
      ITEM_STAMINA_PENALTY: 5
      ITEM_MELEE_PENALTY: 4
      ITEM_TIME_PENALTY: 5
      VEST_DURABILITY: 100
      VEST_ARMOR: 5
  - type: STR_CERAMIC_PLATE_VEST
    tags:
      ITEM_CERAMIC_PLATE_VEST: 1
      ITEM_RESIST_SLOT_INDEX: 1
      ITEM_STAMINA_PENALTY: 10
      ITEM_MELEE_PENALTY: 8
      ITEM_TIME_PENALTY: 10
      ITEM_EXTRA_PROTECTION: 30
      VEST_DURABILITY: 150
      VEST_ARMOR: 10
  - type: STR_IMPACT_VEST
    tags:
      ITEM_IMPACT_VEST: 1
      ITEM_RESIST_SLOT_INDEX: 1
      ITEM_STAMINA_PENALTY: 10
      ITEM_MELEE_PENALTY: 6
      ITEM_TIME_PENALTY: 10
      VEST_DURABILITY: 200
      VEST_ARMOR: 5
  - type: STR_PROTOTYPE_IMPACT_VEST
    tags:
      ITEM_IMPACT_VEST: 1
      ITEM_RESIST_SLOT_INDEX: 1
      VEST_DURABILITY: 200
      VEST_ARMOR: 5
  - type: MUTON_BERSERKER_WEAPON
    tags:
      YTAG_DAMAGE_RETURNED_AS_HP: 33
      YTAG_DAMAGE_RETURNED_RESIST_TYPE: 1 #test this
      ITEM_IMPACT_VEST: 1
      ITEM_MUTON_BERSERKER: 1
      ITEM_RESIST_SLOT_INDEX: 1
  - type: STR_VEHICLE_ARMOR_PLATING
    tags:
      HTAG_HEAL_IMMUNITY: 1
  - type: STR_HWP_RANGEFINDER
    tags:
      HTAG_HEAL_IMMUNITY: 1
  - type: STR_HWP_SMOKE
    tags:
      HTAG_HEAL_IMMUNITY: 1
  - type: STR_LWP_SMOKE
    tags:
      HTAG_HEAL_IMMUNITY: 1
  - type: STR_HWP_FLARE
    tags:
      HTAG_HEAL_IMMUNITY: 1
  - type: STR_LWP_FLARE
    tags:
      HTAG_HEAL_IMMUNITY: 1
  - type: STR_KS23_SHELLS_TEARGAS
    tags:
      TTAG_TEARGASSED_VALUE: 40
      TTAG_TEARGASSED_TIME: 2
  - type: STR_KS23_SHELLS_FLASHBANG
    tags:
      FTAG_DAZE_VALUE: 85 #percentage
      FTAG_DAZE_TIME: 1
  - type: STR_TEARGAS_GRENADE
    tags:
      TTAG_TEARGASSED_VALUE: 50
      TTAG_TEARGASSED_TIME: 2
  - type: STR_NEURALYZER_GRENADE
    tags:
      TTAG_TEARGASSED_VALUE: 100
      TTAG_TEARGASSED_TIME: 3
  - type: STR_ENEMY_NEURALYZER_GRENADE
    tags:
      TTAG_TEARGASSED_VALUE: 100
      TTAG_TEARGASSED_TIME: 3
  - type: STR_MORTAR_SHELL_TEARGAS
    tags:
      TTAG_TEARGASSED_VALUE: 100
      TTAG_TEARGASSED_TIME: 3
  - type: STR_LWP_RIOT_LAUNCHER_TEARGAS_CLIP
    tags:
      TTAG_TEARGASSED_VALUE: 65
      TTAG_TEARGASSED_TIME: 3
  - type: STR_LAUNCHER_TEARGAS
    tags:
      FTAG_DAZE_VALUE: 50 #percentage
      FTAG_DAZE_TIME: 2
  - type: STR_MILKOR_MGL_CLIP_TEARGAS
    tags:
      FTAG_DAZE_VALUE: 45 #percentage
      FTAG_DAZE_TIME: 2
  - type: STR_CRYSTAL_WEAVE
    tags:
      ITEM_RESIST_TYPE_4: 80
      ITEM_MINIMUM_RESIST_TYPE_4: 50
      ITEM_RESIST_SLOT_INDEX: 1
  - type: STR_PERTITE_PLATE
    tags:
      ITEM_RESIST_TYPE_5: 80
      ITEM_MINIMUM_RESIST_TYPE_5: 50
      ITEM_RESIST_SLOT_INDEX: 1
  #- type: STR_EPIC_GOOGLES
    #tags:
      #GTAG_THERMAL_VISION: 1
      #GTAG_NIGHT_VISION: 4
#The resuscitator
  - type: STR_BLOODCLOT_GRENADE
    tags:
      HTAG_HEAL_TYPE: 1 #type of healing effect (1 is resuscitator, 2 bio stasis, 3 overdrive serum)
      HTAG_HEAL_POWER: 1 #the power of the item
      HTAG_HEAL_DURATION: 2 #turns this will run for
#Stasis grenade
  - type: STR_STASIS_GRENADE
    tags:
      HTAG_HEAL_TYPE: 2 #type of healing effect (1 is resuscitator, 2 bio stasis, 3 overdrive serum)
      HTAG_HEAL_POWER: 1 #power of the item
      HTAG_HEAL_DURATION: 4 #turns this will run for
armors:
  # - type: STR_HOSTAGE_ARMOR
    # tags:
      # TAG_IS_INVISIBLE: 0
      # TAG_IS_HOSTAGE: 1
      # TAG_IS_IGNORED: 0
  - type: STR_BLACK_LOTUS_TORONJIN_ARMOR
    tags:
      ARMOR_THE_ONE_PATH_PROFFICIENCY: 100
  - type: STR_BLACK_LOTUS_ARCHWITCH_ARMOR
    tags:
      ARMOR_THE_ONE_PATH_PROFFICIENCY: 40
  - type: STR_BLACK_LOTUS_KNIGHT_ARMOR
    tags:
      ARMOR_THE_ONE_PATH_PROFFICIENCY: 20
  - type: STR_CRAFT_FLARE_TURRET_ARMOR
    tags:
      TAG_IS_INVISIBLE: 1
      TAG_IS_IGNORED: 1
      TAG_IS_BLIND: 1
  - type: STR_HEAVY_TANK_LASER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 50
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_LIGHT_TANK_CANNON_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_LIGHT_TANK_AUTOCANNON_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_LIGHT_TANK_MACHINEGUN_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_LIGHT_TANK_TWIN_MACHINEGUN_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_LIGHT_TANK_AUTOCANNON_PLATED_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 65
  - type: STR_LIGHT_TANK_AUTOCANNON_NIGHT_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_LIGHT_TANK_CANNON_PLATED_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 65
  - type: STR_LIGHT_TANK_MACHINEGUN_PLATED_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 65
  - type: STR_LIGHT_TANK_TWIN_MACHINEGUN_PLATED_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 65
  - type: STR_LIGHT_TANK_CANNON_NIGHT_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_LIGHT_TANK_MACHINEGUN_NIGHT_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_LIGHT_TANK_TWIN_MACHINEGUN_NIGHT_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_LIGHT_TANK_RIOT_LAUNCHER_TEARGAS_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 65
  - type: STR_LIGHT_TANK_RIOT_LAUNCHER_RUBBER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 65
  - type: STR_LIGHT_TANK_RIOT_TASER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 65
  - type: STR_LIGHT_TANK_RIOT_TASER_PLATED_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_ALIEN_LASER_TURRET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_NIGHT_JUMPSUIT_H_UC
    tags: &adventAgentShield
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_XCOM_LIQUIDATOR_ARMOR_SHIELD_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 0
      TTAG_TEARGAS_RESISTANCE: 50
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_HEAVY_RIOT_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_HEAVY_RIOT_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      TTAG_TEARGAS_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_RIOT_VEST_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_RIOT_VEST_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      TTAG_TEARGAS_RESISTANCE: 45
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_RIOT_VEST_SHIELD_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_RIOT_VEST_SHIELD_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      TTAG_TEARGAS_RESISTANCE: 45
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_CAVEMAN_DISGUISE_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 0
  - type: STR_ALIEN_LASER_TURRET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_THE_THING_DOG_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_THE_THING_POLARNIK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_VAMPIRE_QUEEN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_MUMMY_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_BLACK_LOTUS_WAR_WITCH_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_BLACK_LOTUS_AVATAR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_ETHEREAL_SOLDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ETHEREAL_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 35
  - type: STR_ETHEREAL_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_ETHEREAL_SERVITOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_ETHEREAL_ELIMINATOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_ETHEREAL_GUARDIAN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_ETHEREAL_SPEAKER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_ETHEREAL_KEEPER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_ETHEREAL_LEGATE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_ETHEREAL_KNIGHT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_ETHEREAL_GRAND_MASTER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 55
  - type: STR_AQUATOID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 20
  - type: STR_SECTOID_STANDARD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_SECTOID_MEDIC_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_SECTOID_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_SECTOID_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_SECTOID_GUARDIAN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_MIB_PSI_OPS_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_CEREBREAL_STANDARD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CEREBREAL_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CEREBREAL_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CEREBREAL_LARVA_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HUMAN_OSIRON_TECH_TROOPER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 90
  - type: STR_PONTIFF_OF_APOCALYPSE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 20
  - type: STR_SAMAEL_OF_APOCALYPSE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 30
  - type: STR_ALIEN_BRAIN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_MEGAWORM_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SWARMIDS_LARGE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_SWARMIDS_SMALL_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_JANISSARY_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_GILLDOG_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 10
  - type: STR_GILLDOG_ARMOR_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 10
  - type: STR_BIODRONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MERIDIAN_HUNTER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 70
  - type: STR_SILACOID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CELATID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_OOZE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ABOMINATION_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HORROR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 70
  - type: STR_CHRYSSALID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_BADASS_CHRYSSALID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_DEEP_ONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 20
  - type: STR_DEEP_ONE_ARMOR_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 20
  - type: STR_CALCINITE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CARCHARODON_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 20
  - type: STR_CARCHARODON_FERAL_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 20
  - type: STR_TASOTH_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 20
  - type: STR_LOBSTERMAN_FERAL_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_LOBSTERMAN_FERAL_ARMOR_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_LOBSTERMAN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_LOBSTERMAN_ARMOR_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_HALLUCINOID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_XARQUID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_ANTHROPOD_SOLDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ANTHROPOD_NAVIGATOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ANTHROPOD_ENGINEER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_SPITTER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SPITTER_RETRACT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SPITTER_RETRES_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SPITTER_NAKED_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLOATER_SOLDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 40
  - type: STR_FLOATER_ARMOR_GREEN
    tags:
      TTAG_TEARGAS_RESISTANCE: 40
  - type: STR_FLOATER_ARMOR_BLUE
    tags:
      TTAG_TEARGAS_RESISTANCE: 40
  - type: STR_FLOATER_ARMOR_WHITE
    tags:
      TTAG_TEARGAS_RESISTANCE: 40
  - type: STR_FLOATER_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 40
  - type: STR_FLOATER_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 40
  - type: STR_FLOATER_LEGIONNAIRE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_SNAKEMAN_SOLDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SNAKEMAN_ARMOR_GREEN
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SNAKEMAN_ARMOR_BLACK
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SNAKEMAN_ARMOR_BLUE
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SNAKEMAN_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SNAKEMAN_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_MUTON_SOLDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_MUTON_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_MUTON_ENGINEER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_MUTON_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_MUTON_NAVIGATOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_MUTON_SHADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_CHASER_STANDARD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TENTACULAT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CHTONITE_STANDARD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_GAZER_STANDARD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_GAZER_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_GAZER_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_HOLODRONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_WASPITE_STANDARD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_WASPITE_ARMOR_BROWN
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_WASPITE_ARMOR_WHITE
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_WASPITE_LEADER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_WASPITE_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_THE_THING_HEAD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_THE_THING_POLARNIK_TRANSFORMED_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_THE_THING_SHAPELESS_MASS_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SCORPOID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_ANTMAN_WORKER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_ANTMAN_WARRIOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_ANTMAN_QUEEN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_SALAMANDRON_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_CROC_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 65
  - type: STR_MALE_VIP_REPTOID_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 65
  - type: STR_REPTOID_STANDARD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 65
  - type: STR_REPTOID_COMMANDO_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 65
  - type: STR_REPTOID_SHADOW_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 65
  - type: STR_PHARAOH_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_REPTOID_DRAKE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 70
  - type: STR_REPTOID_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 70
  - type: STR_MUCKSTAR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JARHEAD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JARHEAD_PRETENDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_BLACK_LOTUS_MASHINOBI_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ZOMBIE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_MEGASCORPION_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_GIANT_BEETLE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_GIANT_BEETLE_BOMBARDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 65
  - type: STR_GIANT_SPIDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_GIANT_SPIDER_ALLOY_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_GIANT_SPIDER_PURPLE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_GIANT_SPIDER_GREEN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_GIANT_SPIDER_RED_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_GIANT_SPIDER_QUEEN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 40
  - type: STR_GIANT_SPIDER_KING_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE:45
  - type: STR_GHOUL_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_GHOUL_WARRIOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ZOMBIE_BOOMER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ZOMBIE_STERILE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ZOMBIE_GRUBAS_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ZOMBIE_INFECTOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_STRIX_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_TOMB_GUARD_FEMALE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 90
  - type: STR_TOMB_GUARD_MALE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 90
  - type: STR_VAMPIRE_KNIGHT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ZOMBIE_TROOPER_1_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 90
  - type: STR_ZOMBIE_TROOPER_2_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_MEGAZOMBIE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 80
  - type: STR_ZOMBIE_DOGE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 60
  - type: STR_BUG_EYE_GHOST_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SKULL_WRAITH_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_DREAMSPRITE_ARMOR_RED
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIB_ENFORCER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIB_COMBAT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIB_COORDINATOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIB_COMMANDER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIB_POWER_SUIT
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIB_STORMTROOPER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SYNDICATE_MERC_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_SYNDICATE_MERC_CAPTAIN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 45
  - type: STR_CYBERWEB_TECHNOMAD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_CYBERWEB_MYSTEK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_CYBERWEB_SPACE_TECHNOMAD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_EXALT_ENFORCER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 10
  - type: STR_ZSRR_UBEK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 10
  - type: STR_BLACK_LOTUS_WARRIOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 15
  - type: STR_BLACK_LOTUS_ASSASSIN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 15
  - type: STR_BLACK_LOTUS_MANDARIN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 10
  - type: STR_LO_WO_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 50
  - type: STR_SORCERER_OF_DAGON_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 0
  - type: STR_MALE_ENGINEER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 5
  - type: STR_DIVER_SCIENTIST_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MALE_SOLDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 10
  - type: STR_MALE_ELITE_SOLDIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 15
  - type: STR_CRISIS_TROOPER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MALE_MAGMA_HEAVY_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 60
  - type: STR_MALE_MAGMA_SECURITY_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 60
  - type: STR_FEMALE_MAGMA_SECURITY_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 60
  - type: STR_ASTRONAUT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_COUNCIL_SALVAGER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 35
  - type: STR_XCOM_ROBOTURRET_MINIGUN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_XCOM_ROBOTURRET_LASER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_XCOM_ROBOTURRET_PLASMA_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_REPTOID_DRAGONFIRE_TURRET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SEEKER_DRONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CYBERWEB_ROBOSPHERE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CYBERWEB_ROBOTURRET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CYBERWEB_CENTURION_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SYNDICATE_WALKER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MAGMA_CHAINSAWBOT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MAGMA_ROBOTANK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MAGMA_MINITANK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_OBLITERATOR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SECTOPOD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIB_SECTOPOD_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_CYBERDISC_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CYBERMITE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ALIEN_DRONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_LARGE_ALIEN_DRONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_XCOM_FLYING_DRONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SEABOT_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SMALL_TANK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_NIGHT_DRONE_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      TTAG_TEARGAS_RESISTANCE: 100
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_MEDICAL_DRONE_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_COELACANTH_ARMOR_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_CANNON_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_ROCKET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_TRITANIUM_ROCKET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_MINIGUN_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_LASER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_PLASMA_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_MASS_DRIVER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_GAUSS_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_LASER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_PLASMA_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_ROCKET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_TRITANIUM_ROCKET_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_LAUNCHER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_MASS_DRIVER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_GAUSS_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  # - type: STR_SECTOPOD_ARMOR2
    # tags:
      # TTAG_TEARGAS_RESISTANCE: 100
  # - type: STR_SECTOPOD_ARMOR3
    # tags:
      # TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_MIBTANK_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_XCOM_CYBERDISC_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_XCOM_CYBERDISC_ARMOR_ORANGE
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ARMORED_CAR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ARMY_ARMORED_CAR_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_GUNSHIP_ARMOR_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_OUTRUNNER_ARMOR_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TANK_CARRIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HOVERTANK_CARRIER_ARMOR
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_BIOEXO_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_BIOEXO_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HEAVY_TACTICAL_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_HEAVY_TACTICAL_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_HEAVY_TRITANIUM_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_HEAVY_TRITANIUM_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_ARMORED_VEST_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ARMORED_VEST_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ARMORED_VEST_SHIELD_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ARMORED_VEST_SHIELD_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ALLOY_VEST_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ALLOY_VEST_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ALLOY_VEST_SHIELD_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_ALLOY_VEST_SHIELD_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 25
  - type: STR_HAZMAT_ARMOR_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HAZMAT_ARMOR_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TOXI_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TOXI_SUIT_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TOXI_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TOXI_SUIT_H_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CYBER_ARMOR_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 33
  - type: STR_CYBER_ARMOR_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 33
  - type: STR_SYNTHSUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_SYNTHSUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 75
  - type: STR_POWER_ARMOR_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_ARMOR_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_ARMOR_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_ARMOR_H_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_POWER_SUIT_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_POWER_SUIT_H_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_FLYING_SUIT_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_FLYING_SUIT_H_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_STORMTROOPER_ARMOR_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_STORMTROOPER_ARMOR_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_STORMTROOPER_ARMOR_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_STORMTROOPER_ARMOR_H_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JUGGERNAUT_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JUGGERNAUT_SUIT_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JUGGERNAUT_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JUGGERNAUT_SUIT_H_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_DIVING_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_DIVING_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_AQUA_PLASTIC_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_AQUA_PLASTIC_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_AQUA_PLASTIC_SUIT_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_AQUA_PLASTIC_SUIT_H_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SPACE_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SPACE_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SPACE_SUIT_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SPACE_SUIT_OLYMPIAN_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SPACE_SUIT_PROTEAN_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SPACE_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SPACE_SUIT_H_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_WORKSUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_BIOEXO_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HEAVY_TACTICAL_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HEAVY_TRITANIUM_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ARMORED_VEST_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ARMORED_VEST_SHIELD_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ALLOY_VEST_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ALLOY_VEST_SHIELD_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_HAZMAT_ARMOR_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_TOXI_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_CYBER_ARMOR_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SYNTHSUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_ASSAULT_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_ASSAULT_SUIT_KYBEROS_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_ARMOR_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_ARMOR_KYBEROS_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_POWER_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_POWER_SUIT_KYBEROS_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_FLYING_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_FLYING_SUIT_KYBEROS_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_STORMTROOPER_ARMOR_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
#  - type: STR_STORMTROOPER_ARMOR_KYBEROS_UC_UNDERWATER
#    tags:
#      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JUGGERNAUT_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_JUGGERNAUT_SUIT_KYBEROS_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_DIVING_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_AQUA_PLASTIC_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_AQUA_PLASTIC_SUIT_KYBEROS_UC_UNDERWATER
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
  - type: STR_SPACE_SUIT_KYBEROS_UC
    tags:
      TTAG_TEARGAS_RESISTANCE: 100
extended:
  tags: # Remember to add tag definitions to same file as item/armor rulesets!
    RuleItem:
      BIGOB_FOR_PRIMED: int
      HANDOB_FOR_PRIMED: int
      BIGOB_FOR_BROKEN: int
      HANDOB_FOR_BROKEN: int
      FLOOROB_FOR_BROKEN: int
      GENERIC_AMMO: int
      GENERIC_AMMO_AP: int
      NEW_BIGOB_FOR_SLOT_0: int
      WEAPON_SLOT_0: int
      ALLOW_AMMO_TO_RESPRITE: int
      NEW_BIGOB_FOR_WEAPON: int
      NEW_FLOOROB_FOR_WEAPON: int
      NEW_HANDOB_FOR_WEAPON: int
      CURRENT_MOD_OFFSET: RuleList
      ITEM_IMPACT_VEST: int
      ITEM_RESIST_SLOT_INDEX: int
      ITEM_MUTON_BERSERKER: int
      ITEM_RIOT_STAB_VEST: int
      ITEM_GASMASK: int
      ITEM_TINTED_GASMASK: int
      ITEM_ALLOY_GASMASK: int
      ITEM_GASMASK_PROTECTION: int
      ITEM_REACTION_PENALTY: int
      ITEM_FIRING_AIM_PENALTY: int
      ITEM_THROWING_AIM_PENALTY: int
      ITEM_STAMINA_PENALTY: int
      ITEM_TIME_PENALTY: int
      ITEM_MELEE_PENALTY: int
      ITEM_THE_ONE: int
      ITEM_EXTRA_PROTECTION: int
      ITEM_CERAMIC_PLATE_VEST: int
      GASMASK_DURABILITY: int
      VEST_DURABILITY: int
      VEST_ARMOR: int
#shields
      ITEM_IS_SHIELD: int
      SHIELD_ARMOR: int
      SHIELD_DURABILITY: int
      SHIELD_MULTIPLIER: int
      SHIELD_AIMING_PENALTY: int
      SHIELD_SPECIAL_RT: int
      SHIELD_KINETIC_RT: int
      SHIELD_INCENDIARY_RT: int
      SHIELD_CONCUSSIVE_RT: int
      SHIELD_LASER_RT: int
      SHIELD_PLASMA_RT: int
      SHIELD_STUN_RT: int
      SHIELD_CUTTING_RT: int
      SHIELD_CHEMICAL_RT: int
      SHIELD_CHOKING_RT: int
      SHIELD_EMP_RT: int
      SHIELD_ELECTRIC_RT: int
      SHIELD_PSI_RT: int
      SHIELD_WARP_RT: int
      SHIELD_ANTI_E115_RT: int
      SHIELD_BIO_RT: int
      SHIELD_MAX_DMG: int
#support grenades
      HTAG_HEAL_TYPE: int
      HTAG_HEAL_POWER: int
      HTAG_HEAL_DURATION: int
#bloodclot immunity (for AI/vehicles)
      HTAG_HEAL_IMMUNITY: int
#illuminating equipment
      #ITAG_ILLUMINATION_POWER: int
      #ITAG_ILLUMINATION_DURATION: int
      #ITAG_ILLUMINATION_VALUE: int
#teargas
      TTAG_TEARGASSED_VALUE: int
      TTAG_TEARGASSED_TIME: int
      TTAG_TOPSIKER_ADD_POWER: int
#googles
      NTAG_NIGHT_VISION: int
      NTAG_THERMAL_VISION: int
#Hostage/Terrorists
    RuleArmor:
      TAG_IS_HOSTAGE: int
      TAG_IS_IGNORED: int
      TAG_IS_INVISIBLE: int
      TAG_IS_BLIND: int
      TAG_IS_TERRORIST: int
      TAG_IMMUNITY_TIME: int
      TAG_IS_BERSERKER: int
#flare
      ITAG_ILLUMINATION_LIVING: int
      ITAG_ILLUMINATION_DURATION: int #unable to currently determine duration without setting this here as well
#proximity
      PTAG_PROXIMITY_LIVING: int
#teargas res
      TTAG_TEARGAS_RESISTANCE: int
#camoflage attempts
      NTAG_GET_CAMOUFLAGE: int
      ARMOR_THE_ONE_PATH_PROFFICIENCY: int
    BattleItem:
#portable shields
      ITEM_TEST: int
      ITEM_SHIELD_ARMOR: int
      ITEM_SHIELD_DURABILITY: int
      ITEM_SHIELD_AIMING_PENALTY: int
      ITEM_SHIELD_MULTIPLIER: int

      ITEM_SHIELD_SPECIAL_RT: int
      ITEM_SHIELD_KINETIC_RT: int
      ITEM_SHIELD_INCENDIARY_RT: int
      ITEM_SHIELD_CONCUSSIVE_RT: int
      ITEM_SHIELD_LASER_RT: int
      ITEM_SHIELD_PLASMA_RT: int
      ITEM_SHIELD_STUN_RT: int
      ITEM_SHIELD_CUTTING_RT: int
      ITEM_SHIELD_CHEMICAL_RT: int
      ITEM_SHIELD_CHOKING_RT: int
      ITEM_SHIELD_EMP_RT: int
      ITEM_SHIELD_ELECTRIC_RT: int
      ITEM_SHIELD_PSI_RT: int
      ITEM_SHIELD_WARP_RT: int
      ITEM_SHIELD_ANTI_E115_RT: int
      ITEM_SHIELD_BIO_RT: int
      ITEM_SHIELD_MAX_DMG: int

      ITEM_VEST_DURABILITY: int
      ITEM_VEST_ARMOR: int

      ITEM_GASMASK_DURABILITY: int
    BattleUnit:
#flare
      ITAG_ILLUMINATION_STATUS: int
#teargas
      TTAG_ISTEARGASSED: int
      LAST_HIT_FRAME: int
      TTAG_TEARGASSED_ENDTURN: int
      TTAG_TEARGASSED_ORIGINAL_TIMEUNITS: int
      TTAG_TEARGASSED_ORIGINAL_REACTIONS: int
      TTAG_TEARGASSED_ORIGINAL_STAMINA: int
      TTAG_TEARGASSED_ORIGINAL_FIRING: int
      TTAG_TEARGASSED_ORIGINAL_THROWING: int
      TTAG_TEARGASSED_ORIGINAL_MELEE: int
#adaptive camouflage armor
      UNIT_VISIBILITY_AT_NIGHT: int
      UNIT_VISIBILITY_AT_DAY: int
      UNIT_THERMAL_VISION: int
      UNIT_CAMOUFLAGE: int
      UNIT_ORIGINAL_TU: int
      UNIT_EXPENDED_TU: int
#support grenades
      HTAG_STATUS_ACTIVE: int # does this unit have a status active?
      HTAG_STATUS_PASS: int # have we already ran a healing pass this turn?, used to avoid double dipping
      HTAG_TAG_BLOODCLOT: int #resuscitator tag
      HTAG_TAG_STASIS: int #stasis tag
      HTAG_STATUS_WARNTURN: int #which turn does this warn me a turn before it ends?
      HTAG_STATUS_ENDTURN: int #when does this end?
      LAST_HIT_FRAME: int
#current and original wounds
      HTAG_WOUNDS_HEAD: int
      HTAG_WOUNDS_TORSO: int
      HTAG_WOUNDS_RIGHT_ARM: int
      HTAG_WOUNDS_LEFT_ARM: int
      HTAG_WOUNDS_RIGHT_LEG: int
      HTAG_WOUNDS_LEFT_LEG: int
      HTAG_ORIGINAL_HEAD_WOUNDS: int
      HTAG_ORIGINAL_TORSO_WOUNDS: int
      HTAG_ORIGINAL_RIGHT_ARM_WOUNDS: int
      HTAG_ORIGINAL_LEFT_ARM_WOUNDS: int
      HTAG_ORIGINAL_RIGHT_LEG_WOUNDS: int
      HTAG_ORIGINAL_LEFT_LEG_WOUNDS: int
#resistances
      UNIT_RESIST_ITEM_SLOT_1: int
      UNIT_RESIST_ITEM_SLOT_2: int
      UNIT_RESIST_ITEM_SLOT_3: int
      UNIT_RESIST_ITEM_SLOT_4: int
      UNIT_RESIST_ITEM_SLOT_5: int
      UNIT_RESIST_ITEM_SLOT_6: int
      UNIT_RESIST_ITEM_SLOT_7: int
      UNIT_RESIST_ITEM_SLOT_8: int
      UNIT_RESIST_ITEM_SLOT_9: int
      UNIT_RESIST_ITEM_SLOT_10: int
      UNIT_RESIST_ITEM_SLOT_11: int
      UNIT_RESIST_ITEM_SLOT_12: int
      UNIT_RESIST_ITEM_SLOT_13: int
      UNIT_RESIST_ITEM_SLOT_14: int
      UNIT_RESIST_ITEM_SLOT_15: int
      UNIT_RESIST_ITEM_SLOT_16: int
      UNIT_RESIST_ITEM_SLOT_17: int
      UNIT_RESIST_ITEM_SLOT_18: int
      UNIT_RESIST_ITEM_SLOT_19: int
      UNIT_RESIST_ITEM_SLOT_20: int

      UNIT_MUTON_BERSERKER: int
      UNIT_IMPACT_VEST: int
      UNIT_RIOT_STAB_VEST: int
      UNIT_GASMASK: int
      UNIT_TINTED_GASMASK: int
      UNIT_ALLOY_GASMASK: int
      UNIT_GASMASK_PROTECTION: int

      UNIT_REACTION_PENALTY: int
      UNIT_FIRING_AIM_PENALTY: int
      UNIT_THROWING_AIM_PENALTY: int
      UNIT_TIME_PENALTY: int
      UNIT_STAMINA_PENALTY: int
      UNIT_MELEE_PENALTY: int

      UNIT_IS_HOSTAGE: int
      UNIT_IS_IGNORED: int
      UNIT_IS_INVISIBLE: int
      UNIT_IS_TERRORIST: int
      UNIT_IS_BLIND: int
      UNIT_IMMUNITY_TIME: int
      UNIT_THE_ONE: int
      UNIT_THE_ONE_PATH_PROFFICIENCY: int
      UNIT_EXTRA_PROTECTION: int
      UNIT_CERAMIC_PLATE_VEST: int

      UNIT_ORIGINAL_FRONT_ARMOR: int
      UNIT_ORIGINAL_SIDE_ARMOR: int
      UNIT_ORIGINAL_REAR_ARMOR: int
      UNIT_ORIGINAL_UNDER_ARMOR: int
  scripts:
    damageUnit:
      - offset: 0.1 #Support Grenades healing effect
        code: |
          var ptr RuleItem itemRuleset;
          var int statusTag; #the kind of effect going on
          var int statusEffect; #have we had a status pass this turn?
          var int animFrame;
          var int healPower;
          var int healDuration;
          var int healType;
          var int endTurn;
          var int totalWounds; #I'd love to use a table for these variables lol
          var int originalWounds;
          var int headWounds; #0
          var int torsoWounds; #1
          var int rightArmWounds; #2
          var int leftArmWounds; #3
          var int rightLegWounds; #4
          var int leftLegWounds; #5
          var int headOriginalWounds; #0
          var int torsoOriginalWounds; #1
          var int rightArmOriginalWounds; #2
          var int leftArmOriginalWounds; #3
          var int rightLegOriginalWounds; #4
          var int leftLegOriginalWounds; #5
          var int unitHealth;
          var int unitHealthMax;
          var int unitMorale;
          var int unitSanity; #mana
          var int woundImmunityTag; #is this unit immune to wounds?
          var int woundsHealed;
          var int sanityPenalty;
          var int moralePenalty; #mana penalty
          var int stabilizationPenalty; #one time penalty if the wounds would've killed unit this turn if it wasnt for effect
          var int cyclesToSurvive; #number of runs the loop might need to go before unit is safe

          set stabilizationPenalty 8; #one time penalty
          set sanityPenalty 4; #per wound penalty for sanity/mana
          set moralePenalty 4; #per wound penalty for morale
          #debug_log "I am here!"; #this is how I look up the log :)

          damaging_item.getRuleItem itemRuleset; #get healing stats from item
          itemRuleset.getTag healPower Tag.HTAG_HEAL_POWER;
          itemRuleset.getTag healDuration Tag.HTAG_HEAL_DURATION;
          itemRuleset.getTag healType Tag.HTAG_HEAL_TYPE;

          if eq healType 0; # Make sure item has heal effect
            return;
          end;

          unit.getTag statusTag Tag.HTAG_STATUS_ACTIVE; #I don't know how to deal with multiple effects so only one active at a time!
          if neq statusTag 0;
            return;
          end;

          unit.getMana unitSanity; #-4 sanity per wound healed (one time penalty of -10 for every time a stabilization happened)
          unit.getMorale unitMorale; #-5 morale per wound healed
          unit.getFatalwoundsTotal totalWounds;

          #overdose section for healthy soldiers
          if and eq totalWounds 0 eq healType 1;
            sub unitSanity sanityPenalty;
            unit.setMana unitSanity;
            return;
          end;

          # debug_log "These are all the wounds by part 0-5 AND totalwounds";
          unit.getFatalwounds headWounds 0;
          # debug_log headWounds;
          unit.getFatalwounds torsoWounds 1;
          # debug_log torsoWounds;
          unit.getFatalwounds rightArmWounds 2;
          # debug_log rightArmWounds;
          unit.getFatalwounds leftArmWounds 3;
          # debug_log leftArmWounds;
          unit.getFatalwounds rightLegWounds 4;
          # debug_log rightLegWounds;
          unit.getFatalwounds leftLegWounds 5;
          # debug_log leftLegWounds;
          # debug_log totalWounds;

          #bloodclot section
          if and eq healType 1 eq statusTag 0;
            # debug_log "applying bloodclot tag!";
            unit.setTag Tag.HTAG_TAG_BLOODCLOT 1;
            unit.setTag Tag.HTAG_STATUS_ACTIVE 1;
            battle_game.flashMessage "STR_TARGET_IS_BLOODCLOT";
            battle_game.getAnimFrame animFrame;
            unit.setTag Tag.LAST_HIT_FRAME animFrame;

          #stasis section
          else and eq healType 2 eq statusTag 0;
            # debug_log "applying stasis tag!";
            unit.setTag Tag.HTAG_TAG_STASIS 1;
            unit.setTag Tag.HTAG_STATUS_ACTIVE 1;
            battle_game.flashMessage "STR_TARGET_IS_STASIS";
            battle_game.getAnimFrame animFrame;
            unit.setTag Tag.LAST_HIT_FRAME animFrame;

            unit.setTag Tag.HTAG_ORIGINAL_HEAD_WOUNDS headWounds;
            unit.setTag Tag.HTAG_ORIGINAL_TORSO_WOUNDS torsoWounds;
            unit.setTag Tag.HTAG_ORIGINAL_RIGHT_ARM_WOUNDS rightArmWounds;
            unit.setTag Tag.HTAG_ORIGINAL_LEFT_ARM_WOUNDS leftArmWounds;
            unit.setTag Tag.HTAG_ORIGINAL_RIGHT_LEG_WOUNDS rightLegWounds;
            unit.setTag Tag.HTAG_ORIGINAL_LEFT_LEG_WOUNDS leftLegWounds;

            loop var loopCycles 6;
              # debug_log "Current part number is: ";
              # debug_log loopCycles;
              unit.setFatalwounds loopCycles 0;
            end;

          end;

          battle_game.getTurn endTurn;
          add endTurn healDuration; #define end turn for buff
          unit.setTag Tag.HTAG_STATUS_ENDTURN endTurn;
          sub endTurn 1;
          unit.setTag Tag.HTAG_STATUS_WARNTURN endTurn;

          #end of support effects
          return;
      - offset: 1 #Flashbang damage script
        code: |
          var ptr RuleItem itemRuleset;
          var ptr RuleArmor armor_rule;
          var int teargassedTag;
          var int animFrame;
          var int susceptibility;
          var int flashbangSusceptibility;
          var int applyChance;
          var int teargassedValue;
          var int flashbangedValue;
          var int statValue;
          var int debuffValue;
          var int teargassedTime;
          var int flashbangedTime;
          var int maskTag;
          var int endTurn;
          var int flashbangedTag;
          var int tintedMask;
          var int untintedMask;
          var int alloyMask;
          var int maskResistance;
          var int dazeEndTurn;
          var int originalTimeUnits;
          var int originalReactions;
          var int originalMelee;
          var int originalThrowing;
          var int originalFiring;
          var int currentTimeUnits;
          set maskResistance 0;

          damaging_item.getRuleItem itemRuleset; #get debuff stats from item
          itemRuleset.getTag teargassedValue Tag.TTAG_TEARGASSED_VALUE;
          itemRuleset.getTag teargassedTime Tag.TTAG_TEARGASSED_TIME;
          itemRuleset.getTag flashbangedValue Tag.FTAG_DAZE_VALUE;
          itemRuleset.getTag flashbangedTime Tag.FTAG_DAZE_TIME;
          if eq teargassedValue 0; # Make sure item has either flashbang or teargassed effect
            return;
          end;

          unit.getTag teargassedTag Tag.TTAG_ISTEARGASSED;
          unit.getTag flashbangedTag Tag.FTAG_ISDAZED;
          # debug_log teargassedTag;
          # debug_log flashbangedTag;
          # debug_log "Above was teargassedTag and flashbangedTag";

          unit.getTag maskTag Tag.UNIT_RESIST_ITEM_SLOT_2;

          # debug_log "Checking if the unit was wearing a mask of some type";
          # debug_log maskTag;
          # debug_log "Above is maskTag value";
          unit.getTag tintedMask Tag.UNIT_TINTED_GASMASK;
          unit.getTag untintedMask Tag.UNIT_GASMASK;
          unit.getTag alloyMask Tag.UNIT_ALLOY_GASMASK;
          unit.getRuleArmor armor_rule;

          # if eq flashbangedTag 69;
            # if eq tintedMask 1;
              # armor_rule.getTag flashbangSusceptibility Tag.FTAG_FLASHBANG_RESISTANCE;
              # add flashbangSusceptibility 40;
              # battle_game.randomRange applyChance 1 100;
              # debug_log  "applyChance and resistance + 40";
              # debug_log applyChance;
              # debug_log flashbangSusceptibility;
              # if gt flashbangSusceptibility applyChance; # check if target resist teargassed
                # battle_game.flashMessage "Mask protected against Daze!";
                # debug_log "Flashbang cancelled";
                # unit.getTag flashbangedTag Tag.FTAG_ISDAZED;
                # unit.getTag dazeEndTurn Tag.FTAG_DAZE_ENDTURN;
                # unit.getTag originalTimeUnits Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS;
                # unit.getTag originalReactions Tag.FTAG_DAZE_ORIGINAL_REACTIONS;
                # unit.getTag originalFiring Tag.FTAG_DAZE_ORIGINAL_FIRING;
                # unit.getTag originalThrowing Tag.FTAG_DAZE_ORIGINAL_THROWING;
                # unit.getTag originalMelee Tag.FTAG_DAZE_ORIGINAL_MELEE;
                # unit.Stats.getTimeUnits currentTimeUnits;
                # debug_log "Below are original and current TU's";
                # debug_log originalTimeUnits;
                # debug_log currentTimeUnits;
                # # mul originalTimeUnits 2;
                # # debug_log "multiplied timeUnits x 2 equals:";
                # # debug_log originalTimeUnits;
                # unit.Stats.setTimeUnits originalTimeUnits; #revent debuff
                # unit.Stats.setReactions originalReactions;
                # unit.Stats.setFiring originalFiring;
                # unit.Stats.setThrowing originalThrowing;
                # unit.Stats.setMelee originalMelee;
                # unit.setTag Tag.FTAG_ISDAZED 0; #cancel tag
                # if eq teargassedTag 69;
                  # return;
                # else neq teargassedValue 0;
                # end;
              # else;
                # battle_game.flashMessage "Mask failed to protect against Daze!";
                # debug_log "Flashbang went through mask anyways";
                # unit.getTag flashbangedTag Tag.FTAG_ISDAZED;
                # unit.getTag dazeEndTurn Tag.FTAG_DAZE_ENDTURN;
                # unit.getTag originalTimeUnits Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS;
                # unit.getTag originalReactions Tag.FTAG_DAZE_ORIGINAL_REACTIONS;
                # unit.getTag originalFiring Tag.FTAG_DAZE_ORIGINAL_FIRING;
                # unit.getTag originalThrowing Tag.FTAG_DAZE_ORIGINAL_THROWING;
                # unit.getTag originalMelee Tag.FTAG_DAZE_ORIGINAL_MELEE;
                # unit.Stats.getTimeUnits currentTimeUnits;
                # debug_log "Below are original and current TU's";
                # debug_log originalTimeUnits;
                # debug_log currentTimeUnits;
              # return;
               # end;
              # end;
            # end;

          if eq teargassedTag 69; # Make sure unit already have teargassed debuff
            return;
          end;


          armor_rule.getTag susceptibility Tag.TTAG_TEARGAS_RESISTANCE;
          battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply

          # if eq maskTag 1;
            # if eq tintedMask 1;
              # debug_log "mask was tinted!";
            # else eq untintedMask 1;
              # debug_log "mask was NOT tinted!";
            # else eq alloyMask 1;
              # debug_log "mask is alloy tier!";
            # end;
          # end;
          # debug_log "Resistance, teargassedValue, susceptibility and chance are:";
          unit.getTag maskResistance Tag.UNIT_GASMASK_PROTECTION;
          # debug_log maskResistance;
          # debug_log teargassedValue;
          # debug_log susceptibility;
          # debug_log applyChance;
          add susceptibility maskResistance;
          add applyChance teargassedValue;
          # debug_log "maskResistance + susceptibility, apply Chance + teargassedValue";
          # debug_log susceptibility;
          # debug_log applyChance;
          if gt susceptibility applyChance; # check if target resist teargassed
            if eq maskTag 1;
              battle_game.flashMessage "Mask protected your senses!";
              return;
            end;
            battle_game.flashMessage "Unaffected!";
            return;
          end;

          set teargassedTag 69; #set teargassed tag
          unit.setTag Tag.TTAG_ISTEARGASSED teargassedTag;
          if eq maskTag 0;
            #battle_game.flashMessage "STR_TARGET_IS_TEARGASSED";
            battle_game.flashMessage "Grenade was effective!";
          end;
          battle_game.getAnimFrame animFrame;
          unit.setTag Tag.LAST_HIT_FRAME animFrame;

            unit.Stats.getTimeUnits statValue; #remember original TimeUnits stat
            unit.setTag Tag.TTAG_TEARGASSED_ORIGINAL_TIMEUNITS statValue;
            div statValue 2; #calculate TimeUnits debuff, dividing it by 2
            unit.Stats.setTimeUnits statValue; #apply debuff

            unit.getTimeUnits statValue; #also divide actual TUs by 2
            div statValue 2;
            unit.setTimeUnits statValue;

            unit.Stats.getReactions statValue; #remember original Reactions stat
            unit.setTag Tag.TTAG_TEARGASSED_ORIGINAL_REACTIONS statValue;
            battle_game.randomRange debuffValue 15 35; #calculate random, 25-35 for Reactions
            muldiv debuffValue teargassedValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setReactions statValue; #apply Reactions  debuff

            unit.Stats.getFiring statValue; #remember original Firing stat
            unit.setTag Tag.TTAG_TEARGASSED_ORIGINAL_FIRING statValue;
            battle_game.randomRange debuffValue 10 30; #calculate random, 20-30 for Firing
            muldiv debuffValue teargassedValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setFiring statValue; #apply debuff

            unit.Stats.getThrowing statValue; #remember original Throwing stat
            unit.setTag Tag.TTAG_TEARGASSED_ORIGINAL_THROWING statValue;
            battle_game.randomRange debuffValue 10 30; #calculate random, 20-30 for Throwing
            muldiv debuffValue teargassedValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setThrowing statValue; #apply debuff

            unit.Stats.getMelee statValue; #remember original Melee stat
            unit.setTag Tag.TTAG_TEARGASSED_ORIGINAL_MELEE statValue;
            battle_game.randomRange debuffValue 15 25; #calculate random, 10-20 for Melee
            muldiv debuffValue teargassedValue 100;
            sub statValue debuffValue;
            unit.Stats.setMelee statValue; #apply debuff

            battle_game.getTurn endTurn;
            add endTurn teargassedTime; #define end turn for debuff
            unit.setTag Tag.TTAG_TEARGASSED_ENDTURN endTurn;
            if eq maskTag 1;
              battle_game.flashMessage "Mask failed to protect your senses!";
            end;
          return;
    createUnit:
        #*** Sets the frequency and offset for periodic unit recolors for buffs and debuffs ***
      - offset: 1
        code: |
          var int recolorPeriod;
          var int desync;

          set recolorPeriod 32; # units flash every 32 frames
          unit.getId desync;
          offsetmod desync 11 0 recolorPeriod; # creates a desynchronization between unit flashes
          unit.setTag Tag.UNIT_RECOLOR_DESYNC desync;

          return;
      - offset: 2
        code: |
          var int hostageTag;
          var int invisibleTag;
          var int ignoreTag;
          var int terroristTag;
          var ptr RuleArmor armorRuleset;
          var int immunityTag;
          var int blindTag;
          var int berserkerTag;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag hostageTag Tag.TAG_IS_HOSTAGE;
          armorRuleset.getTag invisibleTag Tag.TAG_IS_INVISIBLE;
          armorRuleset.getTag ignoreTag Tag.TAG_IS_IGNORED;
          armorRuleset.getTag blindTag Tag.TAG_IS_BLIND;
          armorRuleset.getTag terroristTag Tag.TAG_IS_TERRORIST;
          armorRuleset.getTag immunityTag Tag.TAG_IMMUNITY_TIME;
          armorRuleset.getTag berserkerTag Tag.TAG_IS_BERSERKER;
          # debug_log "below are hostage, invisible and ignore tags";
          # debug_log hostageTag;
          # debug_log invisibleTag;
          # debug_log ignoreTag;
          # debug_log "BELOW IS BERSERKER TAG";
          # debug_log berserkerTag;
          if eq berserkerTag 1;
            unit.setTag Tag.UNIT_MUTON_BERSERKER berserkerTag;
            unit.setTag Tag.UNIT_IMPACT_VEST berserkerTag;
            # debug_log "UNIT WAS A MUTON BERSERKER";
            return;
          end;
          if or eq hostageTag 1 eq invisibleTag 1 eq ignoreTag 1 eq terroristTag 1 eq blindTag 1; #this could be a if probably
            unit.setTag Tag.UNIT_IS_HOSTAGE hostageTag;
            unit.setTag Tag.UNIT_IS_INVISIBLE invisibleTag;
            unit.setTag Tag.UNIT_IS_IGNORED ignoreTag;
            unit.setTag Tag.UNIT_IS_TERRORIST terroristTag;
            unit.setTag Tag.UNIT_IMMUNITY_TIME immunityTag;
            unit.setTag Tag.UNIT_IS_BLIND blindTag;
            # debug_log "Unit has special visibility tags!, Hostage, Invisible, Ignore:";
            # debug_log hostageTag;
            # debug_log invisibleTag;
            # debug_log ignoreTag;
          end;

          return;
      - offset: 3 #Original values for wieldable shields
        code: |
          var int originalFrontArmor;
          var int originalSideArmor;
          var int originalRearArmor;
          var int originalUnderArmor;

          unit.getArmor originalFrontArmor SIDE_FRONT;
          unit.getArmor originalSideArmor SIDE_LEFT;
          unit.getArmor originalRearArmor SIDE_REAR;
          unit.getArmor originalUnderArmor SIDE_UNDER;
          unit.setTag Tag.UNIT_ORIGINAL_FRONT_ARMOR originalFrontArmor;
          unit.setTag Tag.UNIT_ORIGINAL_SIDE_ARMOR originalSideArmor;
          unit.setTag Tag.UNIT_ORIGINAL_REAR_ARMOR originalRearArmor;
          unit.setTag Tag.UNIT_ORIGINAL_UNDER_ARMOR originalUnderArmor;
          # debug_log "Front armor is: ";
          # debug_log originalFrontArmor;

          return;
    newTurnItem:
      - offset: 3
        code: |
          var ptre BattleUnit itemOwner;
          var ptr RuleItem itemRuleset;
          var ptr RuleArmor armorRuleset;
          var int theOneTag;
          var int profficencyTag;

          item.getOwner itemOwner;

          # If no owner, skip script
          if eq itemOwner null;
            return;
          end;
          # Check the item's slot index; if it's already set on this unit, don't count this item
          item.getRuleItem itemRuleset;
          itemRuleset.getTag theOneTag Tag.ITEM_THE_ONE;
          itemOwner.getRuleArmor armorRuleset;
          armorRuleset.getTag profficencyTag Tag.ARMOR_THE_ONE_PATH_PROFFICIENCY;

          if eq theOneTag 1;
            itemOwner.setTag Tag.UNIT_THE_ONE 1;
            itemOwner.setTag Tag.UNIT_THE_ONE_PATH_PROFFICIENCY profficencyTag;
            # debug_log "This unit walks the path of The One";
            # debug_log "This unit's proffiency is";
            # debug_log profficencyTag;
            end;
          return;
      - offset: 2
        code: |
          var ptre BattleUnit itemOwner;
          var ptr RuleItem itemRuleset;
          var ptr RuleArmor armorRuleset;
          var int itemResistSlotIndex;
          var int mutonBerserker;
          var int impactVest;
          var int stabVest;
          var int ceramicVest;
          var int normalGasmask;
          var int tintedGasmask;
          var int alloyGasmask;
          var int gasmaskProtectionValue;
          var int flashbangResistance;
          var int temp;
          var int dazeTag;
          var int endTurn;
          var int originalTimeUnits;
          var int originalReactions;
          var int originalFiring;
          var int originalThrowing;
          var int originalMelee;
          var int originalStamina;
          var int originalRealStamina;
          var int originalRealTimeUnits;
          var int penaltyFiringTag;
          var int penaltyThrowingTag;
          var int penaltyReactionTag;
          var int penaltyStaminaTag;
          var int penaltyTimeTag;
          var int penaltyMeleeTag;
          var int extraProtectionTag;
          var int remainingExtraProtection;

          item.getOwner itemOwner;

          # If no owner, skip script
          if eq itemOwner null;
            return;
          end;

          # Check the item's slot index; if it's already set on this unit, don't count this item
          item.getRuleItem itemRuleset;
          itemRuleset.getTag itemResistSlotIndex Tag.ITEM_RESIST_SLOT_INDEX;
          itemRuleset.getTag mutonBerserker Tag.ITEM_MUTON_BERSERKER;
          itemRuleset.getTag impactVest Tag.ITEM_IMPACT_VEST;
          itemRuleset.getTag stabVest Tag.ITEM_RIOT_STAB_VEST;
          itemRuleset.getTag normalGasmask Tag.ITEM_GASMASK;
          itemRuleset.getTag tintedGasmask Tag.ITEM_TINTED_GASMASK;
          itemRuleset.getTag gasmaskProtectionValue Tag.ITEM_GASMASK_PROTECTION;
          itemRuleset.getTag penaltyFiringTag Tag.ITEM_FIRING_AIM_PENALTY;
          itemRuleset.getTag penaltyThrowingTag Tag.ITEM_THROWING_AIM_PENALTY;
          itemRuleset.getTag penaltyReactionTag Tag.ITEM_REACTION_PENALTY;
          itemRuleset.getTag penaltyStaminaTag Tag.ITEM_STAMINA_PENALTY;
          itemRuleset.getTag penaltyTimeTag Tag.ITEM_TIME_PENALTY;
          itemRuleset.getTag penaltyMeleeTag Tag.ITEM_MELEE_PENALTY;
          itemRuleset.getTag extraProtectionTag Tag.ITEM_EXTRA_PROTECTION;
          #debug_log itemResistSlotIndex;
          #debug_log mutonBerserker;
          #debug_log "we should have a 1 for both of these first is item resist slot index second is item muton berserker";

          if and eq mutonBerserker 1 eq itemResistSlotIndex 1;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_1;
            #itemOwner.getTag temp Tag.UNIT_MUTON_BERSERKER;
            # debug_log "mutonberserker and itemresistslot are both 1";
            itemOwner.setTag Tag.UNIT_MUTON_BERSERKER 1;
            # debug_log "This is a muton berserker!";

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 1;
            end;

          else and eq impactVest 1 eq itemResistSlotIndex 1;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_1;
            # debug_log "impact vest and itemresistslot are both 1";
            # debug_log "This unit is wearing an impact vest!";
            itemOwner.setTag Tag.UNIT_IMPACT_VEST 1;
            itemOwner.setTag Tag.UNIT_TIME_PENALTY penaltyTimeTag;
            itemOwner.setTag Tag.UNIT_STAMINA_PENALTY penaltyStaminaTag;
            itemOwner.setTag Tag.UNIT_MELEE_PENALTY penaltyMeleeTag;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 1;
            end;

          else and eq stabVest 1 eq itemResistSlotIndex 1;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_1;
            # debug_log "stab vest and itemresistslot are both 1";
            # debug_log "This unit is wearing stab vest!";
            itemOwner.setTag Tag.UNIT_RIOT_STAB_VEST 1;
            itemOwner.setTag Tag.UNIT_TIME_PENALTY penaltyTimeTag;
            itemOwner.setTag Tag.UNIT_STAMINA_PENALTY penaltyStaminaTag;
            itemOwner.setTag Tag.UNIT_MELEE_PENALTY penaltyMeleeTag;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 1;
            end;

          else eq itemResistSlotIndex 1;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_1;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 1;
            end;

          else and eq ceramicVest 1 eq itemResistSlotIndex 1;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_1;
            # debug_log "ceramicVest and itemresistslot are both 1";
            # debug_log "This unit is wearing ceramicVest!";
            itemOwner.setTag Tag.UNIT_TIME_PENALTY penaltyTimeTag;
            itemOwner.setTag Tag.UNIT_STAMINA_PENALTY penaltyStaminaTag;
            itemOwner.setTag Tag.UNIT_MELEE_PENALTY penaltyMeleeTag;
            itemOwner.setTag Tag.UNIT_CERAMIC_PLATE_VEST 1;
            itemOwner.getTag remainingExtraProtection Tag.UNIT_EXTRA_PROTECTION;

            if eq remainingExtraProtection 0;
              set remainingExtraProtection extraProtectionTag;
              itemOwner.setTag Tag.UNIT_EXTRA_PROTECTION remainingExtraProtection;
            end;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 1;
            end;

          else eq itemResistSlotIndex 1;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_1;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 1;
            end;

          else eq itemResistSlotIndex 2;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_2;
            # debug_log "This unit is wearing a mask!";
            itemOwner.setTag Tag.UNIT_GASMASK_PROTECTION gasmaskProtectionValue;

            if eq normalGasmask 1;
              # debug_log "gasmask is not tinted";
              itemOwner.setTag Tag.UNIT_GASMASK 1;
              itemOwner.setTag Tag.UNIT_FIRING_AIM_PENALTY penaltyFiringTag;
              itemOwner.setTag Tag.UNIT_THROWING_AIM_PENALTY penaltyThrowingTag;
              itemOwner.setTag Tag.UNIT_REACTION_PENALTY penaltyReactionTag;
              itemOwner.setTag Tag.UNIT_MELEE_PENALTY penaltyMeleeTag;
            end;
            if eq tintedGasmask 1;
              # debug_log "gasmask is tinted";
              itemOwner.setTag Tag.UNIT_TINTED_GASMASK 1;
              itemOwner.setTag Tag.UNIT_GASMASK 1;
              itemOwner.setTag Tag.UNIT_FIRING_AIM_PENALTY penaltyFiringTag;
              itemOwner.setTag Tag.UNIT_THROWING_AIM_PENALTY penaltyThrowingTag;
              itemOwner.setTag Tag.UNIT_REACTION_PENALTY penaltyReactionTag;
              itemOwner.setTag Tag.UNIT_MELEE_PENALTY penaltyMeleeTag;
              # itemOwner.getRuleArmor armorRuleset;
              # armorRuleset.getTag flashbangResistance Tag.FTAG_FLASHBANG_RESISTANCE;
              # debug_log "Below are flashbang resistance before and after adding 50";
              # debug_log flashbangResistance;
              # add flashbangResistance 50;
              # debug_log flashbangResistance; NOT doable since the pointer is read only
            end;
            if eq alloyGasmask 1;
              # debug_log "Mask is Alloy Respirator";
              itemOwner.setTag Tag.UNIT_ALLOY_GASMASK 1;
              itemOwner.setTag Tag.UNIT_GASMASK 1;
              itemOwner.setTag Tag.UNIT_FIRING_AIM_PENALTY penaltyFiringTag;
              itemOwner.setTag Tag.UNIT_THROWING_AIM_PENALTY penaltyThrowingTag;
              itemOwner.setTag Tag.UNIT_REACTION_PENALTY penaltyReactionTag;
              itemOwner.setTag Tag.UNIT_MELEE_PENALTY penaltyMeleeTag;
              # itemOwner.getRuleArmor armorRuleset;
              # armorRuleset.getTag flashbangResistance Tag.FTAG_FLASHBANG_RESISTANCE;
              # debug_log "Below are flashbang resistance before and after adding 50";
              # debug_log flashbangResistance;
              # add flashbangResistance 50;
              # debug_log flashbangResistance; NOT doable since the pointer is read only
            end;
            # debug_log "The gasmask protection value is: ";
            # debug_log gasmaskProtectionValue;
            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_2 1;
            end;
          else eq itemResistSlotIndex 3;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_3;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_3 1;
            end;
          else eq itemResistSlotIndex 4;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_4;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_4 1;
            end;
          else eq itemResistSlotIndex 5;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_5;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_5 1;
            end;
          else eq itemResistSlotIndex 6;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_6;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_6 1;
            end;
          else eq itemResistSlotIndex 7;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_7;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_7 1;
            end;
          else eq itemResistSlotIndex 8;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_8;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_8 1;
            end;
          else eq itemResistSlotIndex 9;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_9;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_9 1;
            end;
          else eq itemResistSlotIndex 10;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_10;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_10 1;
            end;
          else eq itemResistSlotIndex 11;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_11;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_11 1;
            end;
          else eq itemResistSlotIndex 12;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_12;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_12 1;
            end;
          else eq itemResistSlotIndex 13;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_13;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_13 1;
            end;
          else eq itemResistSlotIndex 14;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_14;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_14 1;
            end;
          else eq itemResistSlotIndex 15;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_15;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_15 1;
            end;
          else eq itemResistSlotIndex 16;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_16;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_16 1;
            end;
          else eq itemResistSlotIndex 17;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_17;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_17 1;
            end;
          else eq itemResistSlotIndex 18;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_18;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_18 1;
            end;
          else eq itemResistSlotIndex 19;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_19;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_19 1;
            end;
          end;

          return;
      - offset: 4 #Unprimes shield if unit has moved!
        code: |
          var ptre BattleUnit itemOwner;
          var ptr RuleItem itemRuleset;

          # item.getOwner itemOwner;

          # # If no owner, skip script
          # if eq itemOwner null;
            # return;
          # end;
          # # Check the item's slot index; if it's already set on this unit, don't count this item
          # item.getRuleItem itemRuleset;
          # itemRuleset.getTag theOneTag Tag.ITEM_THE_ONE;
          # itemOwner.getRuleArmor armorRuleset;
          # armorRuleset.getTag profficencyTag Tag.ARMOR_THE_ONE_PATH_PROFFICIENCY;

          # if eq theOneTag 1;
            # itemOwner.setTag Tag.UNIT_THE_ONE 1;
            # itemOwner.setTag Tag.UNIT_THE_ONE_PATH_PROFFICIENCY profficencyTag;
            # end;
          return;
    accuracyMultiplierBonusStats:
      - offset: 1
        code: |
          var int equipmentSlot1Tag;
          var int equipmentSlot2Tag;
          var int penaltyFiringTag;
          var int penaltyReactionTag;
          var int penaltyThrowingTag;
          var int penaltyTimeTag;
          var int penaltyStaminaTag;
          var int originalFiring;

          unit.getTag equipmentSlot1Tag Tag.UNIT_RESIST_ITEM_SLOT_1;
          unit.getTag equipmentSlot2Tag Tag.UNIT_RESIST_ITEM_SLOT_2;

          if or eq equipmentSlot1Tag 1 eq equipmentSlot2Tag 1;
            # debug_log "accuracyMultiplierBonusStats";
            # debug_log "Target is wearing equipment";
            # debug_log "Bonus equals: ";
            # debug_log bonus;
            # debug_log "External bonuses, ammo and weapon equals:";
            # debug_log external_bonuses;
            # debug_log ammo;
            # debug_log weapon;
            unit.getTag penaltyFiringTag Tag.UNIT_FIRING_AIM_PENALTY;
            unit.getTag penaltyThrowingTag Tag.UNIT_THROWING_AIM_PENALTY;
            unit.Stats.getFiring originalFiring;
            # debug_log "Penalty for firing:";
            # debug_log penaltyFiringTag;
            sub originalFiring penaltyFiringTag;
            set bonus originalFiring;
            # debug_log "Bonus after modifying bonus";
            # debug_log bonus;
          else;
            return bonus;
          end;

          return bonus;
      - offset: 2 #When shield is worn penalties, when shield is worn AND fuse is on, more penalties!
        code: |
          var int shieldTag;
          var ptr BattleItem leftHandWeapon;
          var ptr BattleItem rightHandWeapon;
          var int leftShield;
          var int rightShield;
          var ptr BattleItem ambidexShield;
          var int shieldPenalty;
          var int originalFiring;
          var int shieldFuse;
          var int shieldMultiplier;

          set leftShield 0;
          set rightShield 0;
          unit.getLeftHandWeapon leftHandWeapon;
          unit.getRightHandWeapon rightHandWeapon;
          leftHandWeapon.getTag leftShield Tag.ITEM_IS_SHIELD;
          rightHandWeapon.getTag rightShield Tag.ITEM_IS_SHIELD;

          # debug_log rightShield;
          # debug_log leftShield;
          # debug_log "Above were right and left shield";

          if and eq leftShield 0 eq rightShield 0;
            return bonus;
          end;

          if eq leftShield 1;
            set ambidexShield leftHandWeapon;
          else eq rightShield 1;
            set ambidexShield rightHandWeapon;
          end;

          # debug_log "Shield found!, aim penalties in effect!";
          ambidexShield.getTag shieldPenalty Tag.ITEM_SHIELD_AIMING_PENALTY;
          ambidexShield.getTag shieldMultiplier Tag.ITEM_SHIELD_MULTIPLIER;
          # debug_log "Shield penatly is equal to";
          # debug_log shieldPenalty;
          ambidexShield.isFuseEnabled shieldFuse;
          if eq shieldFuse 1;
            debug_log "Shield multiplier is equal to!";
            debug_log shieldMultiplier;
            div shieldMultiplier 100;
            mul shieldPenalty shieldMultiplier;
          end;

          unit.Stats.getFiring originalFiring;

          sub originalFiring shieldPenalty;

          if le bonus originalFiring;
            debug_log "Penalty actually made this equal OR even more than before! denying";
            debug_log bonus;
            debug_log originalFiring;
            debug_log shieldPenalty;
            sub bonus shieldPenalty;
            return bonus;
          end;

          set bonus originalFiring;

          return bonus;
    throwMultiplierBonusStats:
      - offset: 1
        code: |
          var int equipmentSlot1Tag;
          var int equipmentSlot2Tag;
          var int penaltyThrowingTag;
          var int originalThrowing;

          unit.getTag equipmentSlot1Tag Tag.UNIT_RESIST_ITEM_SLOT_1;
          unit.getTag equipmentSlot2Tag Tag.UNIT_RESIST_ITEM_SLOT_2;

          if or eq equipmentSlot1Tag 1 eq equipmentSlot2Tag 1;
            # debug_log "throwMultiplierBonusStats";
            # debug_log "Target is wearing equipment";
            # debug_log "Bonus equals: ";
            # debug_log bonus;
            # debug_log "External bonuses, ammo and weapon equals:";
            # debug_log external_bonuses;
            # debug_log ammo;
            # debug_log weapon;
            unit.getTag penaltyThrowingTag Tag.UNIT_THROWING_AIM_PENALTY;
            unit.Stats.getThrowing originalThrowing;
            # debug_log "Penalty for throwing:";
            # debug_log penaltyThrowingTag;
            sub originalThrowing penaltyThrowingTag;
            set bonus originalThrowing;
            # debug_log "Bonus after modifying bonus";
            # debug_log bonus;
          else;
            return bonus;
          end;

          return bonus;
    meleeMultiplierBonusStats:
      - offset: 1
        code: |
          var int equipmentSlot1Tag;
          var int equipmentSlot2Tag;
          var int penaltyMeleeTag;
          var int originalMelee;

          unit.getTag equipmentSlot1Tag Tag.UNIT_RESIST_ITEM_SLOT_1;
          unit.getTag equipmentSlot2Tag Tag.UNIT_RESIST_ITEM_SLOT_2;

          if or eq equipmentSlot1Tag 1 eq equipmentSlot2Tag 1;
            # debug_log "meleeMultiplierBonusStats";
            # debug_log "Target is wearing equipment";
            # debug_log "Bonus equals: ";
            # debug_log bonus;
            # debug_log "External bonuses, ammo and weapon equals:";
            # debug_log external_bonuses;
            # debug_log ammo;
            # debug_log weapon;
            unit.getTag penaltyMeleeTag Tag.UNIT_MELEE_PENALTY;
            unit.Stats.getMelee originalMelee;
            # debug_log "Penalty for melee:";
            # debug_log penaltyMeleeTag;
            sub originalMelee penaltyMeleeTag;
            set bonus originalMelee;
            # debug_log "Bonus after modifying bonus";
            # debug_log bonus;
          else;
            return bonus;
          end;

          return bonus;
    closeQuartersMultiplierBonusStats:
      - offset: 1
        code: |
          var int equipmentSlot1Tag;
          var int equipmentSlot2Tag;
          var int penaltyReactionTag;
          var int originalReactions;
          var int penaltyMeleeTag;
          var int originalMelee;

          unit.getTag equipmentSlot1Tag Tag.UNIT_RESIST_ITEM_SLOT_1;
          unit.getTag equipmentSlot2Tag Tag.UNIT_RESIST_ITEM_SLOT_2;
          # debug_log "This is the original bonus for CLOSE QUARTERS MULTIPLIER!";
          # debug_log bonus;

          if or eq equipmentSlot1Tag 1 eq equipmentSlot2Tag 1;
            # debug_log "closeQuartersMultiplierBonusStats";
            # debug_log "Target is wearing equipment";
            # debug_log "Bonus equals: ";
            # debug_log bonus;
            # debug_log "External bonuses, ammo and weapon equals:";
            # debug_log external_bonuses;
            # debug_log ammo;
            # debug_log weapon;
            unit.getTag penaltyMeleeTag Tag.UNIT_MELEE_PENALTY;
            unit.getTag penaltyReactionTag Tag.UNIT_REACTION_PENALTY;
            unit.Stats.getMelee originalMelee;
            unit.Stats.getReactions originalReactions;
            # debug_log "Penalty for melee and reactions";
            # debug_log penaltyMeleeTag;
            # debug_log penaltyReactionTag;
            div penaltyMeleeTag 2;
            div penaltyReactionTag 2;
            add penaltyMeleeTag penaltyReactionTag;
            sub originalMelee penaltyMeleeTag;
            set bonus originalMelee;
            # debug_log "Bonus after modifying bonus (half of each then added)";
            # debug_log bonus;
          else;
            return bonus;
          end;

          return bonus;
    newTurnUnit:
      - offset: 1
        code: |
          var int berserkerTag;

          # Clear recolor tags
          unit.setTag Tag.UNIT_RECOLOR_START_FRAME 0;
          unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 0;
          unit.setTag Tag.UNIT_RECOLOR_COLOR 0;

          unit.getTag berserkerTag Tag.UNIT_MUTON_BERSERKER;

          # Clear all unit resist types and minimums so resistance items can set again
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_2 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_3 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_4 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_5 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_6 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_7 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_8 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_9 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_10 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_11 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_12 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_13 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_14 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_15 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_16 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_17 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_18 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_19 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_20 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_0 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_1 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_2 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_3 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_4 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_5 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_6 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_7 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_8 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_9 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_10 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_11 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_12 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_13 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_14 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_15 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_16 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_17 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_18 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_19 0;

          if eq berserkerTag 1;
            return;
          end;

          unit.setTag Tag.UNIT_IMPACT_VEST 0;
          unit.setTag Tag.UNIT_RIOT_STAB_VEST 0;
          unit.setTag Tag.UNIT_GASMASK 0;
          unit.setTag Tag.UNIT_TINTED_GASMASK 0;
          unit.setTag Tag.UNIT_ALLOY_GASMASK 0;
          unit.setTag Tag.UNIT_GASMASK_PROTECTION 0;
          unit.setTag Tag.UNIT_FIRING_AIM_PENALTY 0;
          unit.setTag Tag.UNIT_THROWING_AIM_PENALTY 0;
          unit.setTag Tag.UNIT_REACTION_PENALTY 0;
          unit.setTag Tag.UNIT_STAMINA_PENALTY 0;
          unit.setTag Tag.UNIT_TIME_PENALTY 0;
          unit.setTag Tag.UNIT_MELEE_PENALTY 0;
          unit.setTag Tag.UNIT_CERAMIC_PLATE_VEST 0;
          # unit.setTag Tag.UNIT_EXTRA_PROTECTION 0;
          return;
      - offset: 5 #Reduces immunity time
        code: |
          var int immunityTag;
          var int hostageTag;
          var int ignoreTag;

          # Make sure this doesn't run an extra time when players/enemies have a turn
          if or eq side 0 eq side 1;
            return;
          end;

          # var ptre RuleArmor armorRuleset;
          # unit.getRuleArmor armorRuleset;
          unit.getTag immunityTag Tag.UNIT_IMMUNITY_TIME;
          unit.getTag hostageTag Tag.UNIT_IS_HOSTAGE;
          unit.getTag ignoreTag Tag.UNIT_IS_IGNORED;
          if and eq hostageTag 0 eq ignoreTag 0;
            return;
          end;

          if le immunityTag 0;
            # debug_log "immunity time was 0 or less, returning";
            return;
          end;

          # debug_log "immunity Time equals";
          # debug_log immunityTag;
          # debug_log "current turn is";
          # debug_log turn;
          sub immunityTag 1;
          unit.setTag Tag.UNIT_IMMUNITY_TIME immunityTag;

          return;
      - offset: 4 #Flashbang ongoing check script
        code: |
          var int currTurn;
          var int endTurn;
          var int teargassedTag;
          var int originalTimeUnits;
          var int originalReactions;
          var int originalFiring;
          var int originalThrowing;
          var int originalMelee;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          unit.getTag teargassedTag Tag.TTAG_ISTEARGASSED;
          unit.getTag endTurn Tag.TTAG_TEARGASSED_ENDTURN;
          unit.getTag originalTimeUnits Tag.TTAG_TEARGASSED_ORIGINAL_TIMEUNITS;
          unit.getTag originalReactions Tag.TTAG_TEARGASSED_ORIGINAL_REACTIONS;
          unit.getTag originalFiring Tag.TTAG_TEARGASSED_ORIGINAL_FIRING;
          unit.getTag originalThrowing Tag.TTAG_TEARGASSED_ORIGINAL_THROWING;
          unit.getTag originalMelee Tag.TTAG_TEARGASSED_ORIGINAL_MELEE;

          battle_game.getTurn currTurn;

          if eq teargassedTag 69;
            if eq currTurn endTurn;
              unit.Stats.setTimeUnits originalTimeUnits; #revent debuff
              unit.Stats.setReactions originalReactions;
              unit.Stats.setFiring originalFiring;
              unit.Stats.setThrowing originalThrowing;
              unit.Stats.setMelee originalMelee;
              unit.setTag Tag.TTAG_ISTEARGASSED 0; #cancel tag
              battle_game.flashMessage "STR_TARGET_IS_NOT_TEARGASSED";
            end;
          end;

          return;
      - offset: 5 #Support Grenades effects ongoing check script
        code: |
          var int currTurn;
          var int warningTurn;
          var int endTurn;
          var int statusTag;
          var int healValue;
          var int totalWounds;
          var int unitSanity;
          var int unitMorale;
          var int unitHealth;
          var int unitHealthMax;
          var int stabilizationPenalty;
          var int sanityPenalty;
          var int moralePenalty;
          var int cyclesToSurvive;
          var int woundsHealed;
          var int headWounds;
          var int torsoWounds;
          var int rightArmWounds;
          var int leftArmWounds;
          var int rightLegWounds;
          var int leftLegWounds;
          var int headOriginalWounds;
          var int torsoOriginalWounds;
          var int rightArmOriginalWounds;
          var int leftArmOriginalWounds;
          var int rightLegOriginalWounds;
          var int leftLegOriginalWounds;
          var int stasisTag;
          var int bloodclotTag;
          var int stabilized;

          set stabilizationPenalty 8;
          set sanityPenalty 4;
          set moralePenalty 4;
          set woundsHealed 0;
          set stabilized 0;

          unit.getTag statusTag Tag.HTAG_STATUS_ACTIVE;
          if eq statusTag 1;
            unit.getMana unitSanity; #-4 sanity per wound healed (one time penalty of -10 for every time a stabilization happened)
            unit.getMorale unitMorale; #-5 morale per wound healed

            unit.getFatalwoundsTotal totalWounds;
            # debug_log "total wounds NEW UNIT TURN EVENT";
            # debug_log totalWounds;

            unit.getFatalwounds headWounds 0;
            unit.getFatalwounds torsoWounds 1;
            unit.getFatalwounds rightArmWounds 2;
            unit.getFatalwounds leftArmWounds 3;
            unit.getFatalwounds rightLegWounds 4;
            unit.getFatalwounds leftLegWounds 5;

            unit.getHealth unitHealth;
            unit.getHealthMax unitHealthMax;
            unit.getTag endTurn Tag.HTAG_STATUS_ENDTURN;
            unit.getTag warningTurn Tag.HTAG_STATUS_WARNTURN;
            # debug_log "This is the status ENDTURN";
            # debug_log endTurn;
            # debug_log "This is the status WARNTURN";
            # debug_log warningTurn;

            battle_game.getTurn currTurn;
            # debug_log "This is the currTurn variable";
            # debug_log currTurn;
            unit.getTag bloodclotTag Tag.HTAG_TAG_BLOODCLOT;
            unit.getTag stasisTag Tag.HTAG_TAG_STASIS;

          end;

          # Make sure this doesn't run an extra time when civilians or aliens have a turn
          if or eq side 1 eq side 2;
            return;
          end;

          if eq bloodclotTag 1;
            # debug_log "this unit has a heal tag present!";
            # debug_log unitHealth;
            # debug_log totalWounds;
            # debug_log "that was unitHealth and totalWounds";
            if or lt unitHealth totalWounds eq unitHealth totalWounds;
              # debug_log "wounds will kill unit next turn, stabilizing! (NON HIT EVENT)";
              sub unitMorale stabilizationPenalty;
              sub unitSanity stabilizationPenalty;
              set cyclesToSurvive totalWounds;
              sub cyclesToSurvive unitHealth;
              add cyclesToSurvive 1;

              loop var loopCycles cyclesToSurvive;
                # debug_log "Emergency stabilization loop (NON HIT EVENT)!";
                if neq headWounds 0;
                  sub headWounds 1;
                  add woundsHealed 1;
                  unit.setFatalwounds 0 headWounds;
                else neq torsoWounds 0;
                  sub torsoWounds 1;
                  add woundsHealed 1;
                  unit.setFatalwounds 1 torsoWounds;
                else neq rightArmWounds 0;
                  sub rightArmWounds 1;
                  add woundsHealed 1;
                  unit.setFatalwounds 2 rightArmWounds;
                else neq leftArmWounds 0;
                  sub leftArmWounds 1;
                  add woundsHealed 1;
                  unit.setFatalwounds 3 leftArmWounds;
                else neq rightLegWounds 0;
                  sub rightLegWounds 1;
                  add woundsHealed 1;
                  unit.setFatalwounds 4 rightLegWounds;
                else neq leftLegWounds 0;
                  sub leftLegWounds 1;
                  add woundsHealed 1;
                  unit.setFatalwounds 5 leftLegWounds;
                end;
              # debug_log "This is the amount of wounds healed: ";
              # debug_log woundsHealed;
              set stabilized 1;
              end;
            # debug_log "Administering penalties based on totalWounds";
            else and neq totalWounds 0 eq stabilized 0;
              if neq headWounds 0;
                sub headWounds 1;
                add woundsHealed 1;
                unit.setFatalwounds 0 headWounds;
              else neq torsoWounds 0;
                sub torsoWounds 1;
                add woundsHealed 1;
                unit.setFatalwounds 1 torsoWounds;
              else neq rightArmWounds 0;
                sub rightArmWounds 1;
                add woundsHealed 1;
                unit.setFatalwounds 2 rightArmWounds;
              else neq leftArmWounds 0;
                sub leftArmWounds 1;
                add woundsHealed 1;
                unit.setFatalwounds 3 leftArmWounds;
              else neq rightLegWounds 0;
                sub rightLegWounds 1;
                add woundsHealed 1;
                unit.setFatalwounds 4 rightLegWounds;
              else neq leftLegWounds 0;
                sub leftLegWounds 1;
                add woundsHealed 1;
                unit.setFatalwounds 5 leftLegWounds;
              end;
            end;

            mul woundsHealed sanityPenalty;
            sub unitSanity woundsHealed;
            sub unitMorale woundsHealed;
            unit.setMana unitSanity;
            unit.setMorale unitMorale;
            set woundsHealed 0;

          end;
          if eq stasisTag 1;
            # debug_log "we're on stasis ";
            # debug_log "totalWounds are: ";
            # debug_log totalWounds;
            if neq totalWounds 0;
              unit.getTag headOriginalWounds Tag.HTAG_ORIGINAL_HEAD_WOUNDS;
              unit.getTag torsoOriginalWounds Tag.HTAG_ORIGINAL_TORSO_WOUNDS;
              unit.getTag rightArmOriginalWounds Tag.HTAG_ORIGINAL_RIGHT_ARM_WOUNDS;
              unit.getTag leftArmOriginalWounds Tag.HTAG_ORIGINAL_LEFT_ARM_WOUNDS;
              unit.getTag rightLegOriginalWounds Tag.HTAG_ORIGINAL_RIGHT_LEG_WOUNDS;
              unit.getTag leftLegOriginalWounds Tag.HTAG_ORIGINAL_LEFT_LEG_WOUNDS;
              if neq headWounds 0;
                add headOriginalWounds headWounds;
                unit.setTag Tag.HTAG_ORIGINAL_HEAD_WOUNDS headOriginalWounds;
              end;
              if neq torsoWounds 0;
                add torsoOriginalWounds torsoWounds;
                unit.setTag Tag.HTAG_ORIGINAL_TORSO_WOUNDS torsoOriginalWounds;
              end;
              if neq rightArmWounds 0;
                add rightArmOriginalWounds rightArmWounds;
                unit.setTag Tag.HTAG_ORIGINAL_RIGHT_ARM_WOUNDS rightArmOriginalWounds;
              end;
              if neq leftArmWounds 0;
                add leftArmOriginalWounds leftArmWounds;
                unit.setTag Tag.HTAG_ORIGINAL_LEFT_ARM_WOUNDS leftArmOriginalWounds;
              end;
              if neq rightLegWounds 0;
                add rightLegOriginalWounds rightLegWounds;
                unit.setTag Tag.HTAG_ORIGINAL_RIGHT_LEG_WOUNDS rightLegOriginalWounds;
              end;
              if neq leftLegWounds 0;
                add leftLegOriginalWounds leftLegWounds;
                unit.setTag Tag.HTAG_ORIGINAL_LEFT_LEG_WOUNDS leftLegOriginalWounds;
              end;

              loop var loopCycles 6; #saving the active wounds while pausing the new ones
                unit.setFatalwounds loopCycles 0;
                # debug_log "im pausing wounds!";
              end;

              set totalWounds 0;
              # debug_log "Non-hit event, new wounds have been saved";

            end;
          end;
          if and eq currTurn endTurn eq bloodclotTag 1;
            unit.setTag Tag.HTAG_TAG_BLOODCLOT 0; #cancel tag
            unit.setTag Tag.HTAG_STATUS_ACTIVE 0; #cancel tag
            unit.setTag Tag.HTAG_STATUS_WARNTURN 0;
            battle_game.flashMessage "STR_TARGET_IS_NOT_BLOODCLOT";
          end;
          if and eq currTurn warningTurn eq stasisTag 1;
            # debug_log "the unit's stasis tag is about to expire!...";
            battle_game.flashMessage "STR_STASIS_ALMOST_OVER";
          end;
          if and eq currTurn endTurn eq stasisTag 1;
            # debug_log "the unit's stasis tag has expired... removing tag...!";
            unit.setTag Tag.HTAG_STATUS_ACTIVE 0; #cancel tag
            unit.setTag Tag.HTAG_STATUS_WARNTURN 0;
            unit.setTag Tag.HTAG_TAG_STASIS 0;
            battle_game.flashMessage "STR_TARGET_IS_NOT_STASIS";

            unit.getTag headOriginalWounds Tag.HTAG_ORIGINAL_HEAD_WOUNDS;
            unit.getTag torsoOriginalWounds Tag.HTAG_ORIGINAL_TORSO_WOUNDS;
            unit.getTag rightArmOriginalWounds Tag.HTAG_ORIGINAL_RIGHT_ARM_WOUNDS;
            unit.getTag leftArmOriginalWounds Tag.HTAG_ORIGINAL_LEFT_ARM_WOUNDS;
            unit.getTag rightLegOriginalWounds Tag.HTAG_ORIGINAL_RIGHT_LEG_WOUNDS;
            unit.getTag leftLegOriginalWounds Tag.HTAG_ORIGINAL_LEFT_LEG_WOUNDS;

            add headOriginalWounds headWounds;
            add torsoOriginalWounds torsoWounds;
            add rightArmOriginalWounds rightArmWounds;
            add leftArmOriginalWounds leftArmWounds;
            add rightLegOriginalWounds rightLegWounds;
            add leftLegOriginalWounds leftLegWounds;

            unit.setFatalwounds 0 headOriginalWounds;
            unit.setFatalwounds 1 torsoOriginalWounds;
            unit.setFatalwounds 2 rightArmOriginalWounds;
            unit.setFatalwounds 3 leftArmOriginalWounds;
            unit.setFatalwounds 4 rightLegOriginalWounds;
            unit.setFatalwounds 5 leftLegOriginalWounds;
            # debug_log "Wounds are back!";
          end;

          return;
      - offset: 1
        code: |
          var int berserkerTag;

          # Clear recolor tags
          unit.setTag Tag.UNIT_RECOLOR_START_FRAME 0;
          unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 0;
          unit.setTag Tag.UNIT_RECOLOR_COLOR 0;

          unit.getTag berserkerTag Tag.UNIT_MUTON_BERSERKER;

          # Clear all unit resist types and minimums so resistance items can set again
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_2 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_3 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_4 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_5 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_6 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_7 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_8 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_9 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_10 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_11 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_12 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_13 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_14 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_15 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_16 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_17 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_18 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_19 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_20 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_0 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_1 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_2 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_3 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_4 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_5 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_6 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_7 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_8 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_9 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_10 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_11 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_12 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_13 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_14 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_15 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_16 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_17 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_18 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_19 0;

          if eq berserkerTag 1;
            return;
          end;

          unit.setTag Tag.UNIT_IMPACT_VEST 0;
          unit.setTag Tag.UNIT_RIOT_STAB_VEST 0;
          unit.setTag Tag.UNIT_GASMASK 0;
          unit.setTag Tag.UNIT_TINTED_GASMASK 0;
          unit.setTag Tag.UNIT_ALLOY_GASMASK 0;
          unit.setTag Tag.UNIT_GASMASK_PROTECTION 0;
          unit.setTag Tag.UNIT_FIRING_AIM_PENALTY 0;
          unit.setTag Tag.UNIT_THROWING_AIM_PENALTY 0;
          unit.setTag Tag.UNIT_REACTION_PENALTY 0;
          unit.setTag Tag.UNIT_STAMINA_PENALTY 0;
          unit.setTag Tag.UNIT_TIME_PENALTY 0;
          unit.setTag Tag.UNIT_MELEE_PENALTY 0;
          unit.setTag Tag.UNIT_CERAMIC_PLATE_VEST 0;
          # unit.setTag Tag.UNIT_EXTRA_PROTECTION 0;
          return;
    hitUnit:
      - offset: 3
        code: |
          var ptr RuleDamageType itemDamage;
          var ptr RuleItem damagingRuleItem;
          var ptr BattleUnit ownerCheck1;
          var ptr BattleUnit ownerCheck2;
          var int isDamageAOE;
          var ptr Tile attackerTile;
          var ptr Tile unitTile;
          var int attackerX;
          var int attackerY;
          var int attackerZ;
          var int unitX;
          var int unitY;
          var int unitZ;
          var int distanceTile;
          var int vestArmor;
          var int mutonBerserkerTag;
          var int stabVest;

          set isDamageAOE 0;

          # debug_log "VEST TIME!";
          unit.getTag vestArmor Tag.UNIT_IMPACT_VEST;
          unit.getTag mutonBerserkerTag Tag.UNIT_MUTON_BERSERKER;
          unit.getTag stabVest Tag.UNIT_RIOT_STAB_VEST;
          # debug_log vestArmor;
          # debug_log mutonBerserkerTag;
          # debug_log stabVest;
          # debug_log "Above was vestArmor, mutonBerserkerTag, and stabVest";
          if eq mutonBerserkerTag 1;
            # debug_log "mutonberserker tag was one! ";
          end;
          if and neq vestArmor 1 neq mutonBerserkerTag 1 neq stabVest 1;
            # debug_log "No vests found, aborting!";
            return power part side;
          end;

          damaging_item.getRuleItem damagingRuleItem;
          # debug_log damagingRuleItem;
          damagingRuleItem.getDamageType itemDamage;
          # debug_log itemDamage;
          itemDamage.isAreaOfEffect isDamageAOE;
          # debug_log isDamageAOE;
          # debug_log "damaging_type equals:";
          # debug_log damaging_type;
          if eq damaging_type 0;
            # debug_log "damage was special or type 0, ignoring (can be from Insanity effects)";
            return power part side;
          end;

          if and eq damaging_type 9 eq isDamageAOE 1;
            # debug_log "damage is smoke and is aoe, ignoring";
            return power part side;
          end;

          if eq stabVest 1;
            if neq damaging_type 7;
              battle_game.flashMessage "Damage bypasses vest!";
              return power part side;
            else eq damaging_type 7;
              # debug_log "damage was cutting/melee, proceeding to reduce damage!";
            else eq damaging_type 0;
              return power part side;
            end;
          end;

          if eq vestArmor 1;
            if and neq damaging_type 1 neq damaging_type 3 neq damaging_type 6;
              # debug_log "Damage was not Kinetic, Concussive,or Stun";
              if or eq damaging_type 9 eq damaging_type 7 eq damaging_type 0;
                # debug_log "Damage was smoke/choke OR cutting, so not displaying this";
                return power part side;
              end;
              battle_game.flashMessage "Damage bypasses vest!";
              return power part side;
            end;
          end;

          if and neq isDamageAOE 0 eq mutonBerserkerTag 0;
             # debug_log "Damage was AOE and unit is not a muton berserker";
             return power part side;
          end;

          #This should only run IF the maximum distance is NOT exceeded (4 tiles right now)
          if eq vestArmor 1;
            attacker.getPosition.getX attackerX;
            attacker.getPosition.getY attackerY;
            attacker.getPosition.getZ attackerZ;
            battle_game.getTile attackerTile attackerX attackerY attackerZ;
            unit.getPosition.getX unitX;
            unit.getPosition.getY unitY;
            unit.getPosition.getZ unitZ;
            battle_game.getTile unitTile unitX unitY unitZ;
            attackerTile.getDistanceTile distanceTile unitTile;
            # debug_log distanceTile;
            # debug_log "Above were distanceTile and distanceVoxel";
            if gt distanceTile 4;
              # debug_log "Distance was greater than 4!";
              # debug_log distanceTile;
              return power part side;
            end;
          end;

          if eq mutonBerserkerTag 1;
            # debug_log "vest owner is a muton berserker, checking if weapon damaging it is its own fist lol";
            damaging_item.getOwner ownerCheck1;
            # debug_log ownerCheck1;
            # debug_log unit;
            # debug_log "Above were ownerCheck1 and unit";
            if eq ownerCheck1 unit;
              set power 0;
              # debug_log "Muton is hitting itself... aborting damage";
              return power part side;
            end;
          end;

          if le power 0;
            return power part side;
          end;

          if or eq side SIDE_LEFT eq side SIDE_RIGHT; #33%
            set vestArmor 3;
            battle_game.flashMessage "Damage reduced by: 33%";
          else eq side SIDE_UNDER; #20%
            set vestArmor 5;
            battle_game.flashMessage "Damage reduced by: 20%";
          else eq side SIDE_REAR; #25%
            battle_game.flashMessage "Damage reduced by: 25%";
            set vestArmor 4;
          else eq side SIDE_FRONT; #50%
            battle_game.flashMessage "Damage reduced by: 50%";
            set vestArmor 2;
          end;

          # debug_log "first is original power, after is power after reductions";
          # debug_log power;
          #We're only removing that percentage, not making the damage that percentage
          div power vestArmor;
          sub vestArmor 1;
          mul power vestArmor;

          # debug_log power;

          return power part side;
      - offset: 4
        code: |
          var ptr RuleDamageType itemDamage;
          var ptr RuleItem damagingRuleItem;
          var ptr BattleUnit ownerCheck1;
          var ptr BattleUnit ownerCheck2;
          var int isDamageAOE;
          var int untintedValue;
          var int tintedValue;
          var int alloyValue;
          var int itemResistSlotIndex;
          var int gasmaskProtectionValue;
          set isDamageAOE 0;

          unit.getTag itemResistSlotIndex Tag.UNIT_RESIST_ITEM_SLOT_2;
          # debug_log "MASK TIME!";
          if neq itemResistSlotIndex 1;
            # debug_log "No mask found, aborting";
            return power part side;
          end;

          unit.getTag untintedValue Tag.UNIT_GASMASK;
          unit.getTag tintedValue Tag.UNIT_TINTED_GASMASK;
          unit.getTag alloyValue Tag.UNIT_ALLOY_GASMASK;
          unit.getTag gasmaskProtectionValue Tag.UNIT_GASMASK_PROTECTION;
          # debug_log untintedValue;
          # debug_log tintedValue;
          # debug_log "Above was untintedValue and tintedValue"; #TODO: Might need to integrate the flashback script here to reference the tinted part

          damaging_item.getRuleItem damagingRuleItem;
          # debug_log damagingRuleItem;
          damagingRuleItem.getDamageType itemDamage;
          # debug_log itemDamage;
          itemDamage.isAreaOfEffect isDamageAOE;
          # debug_log isDamageAOE;
          # debug_log "damaging_type equals:";
          # debug_log damaging_type;

          if eq damaging_type 0;
            # debug_log "damage was special or type 0, ignoring (can be from Insanity effects)";
            return power part side;
          end;

          if eq itemResistSlotIndex 1;
            if and neq damaging_type 6 neq damaging_type 8 neq damaging_type 9;
              # debug_log "Damage was not Stun, Chemical,or Smoke, ignoring";
             # battle_game.flashMessage "Damage bypasses mask!";
              return power part side;
            else;
              # debug_log "Damage was Stun, Chemical or Smoke, procceeding";
            end;
          end;

          if neq isDamageAOE 1;
             # debug_log "Damage was NOT AOE";
             return power part side;
          end;

          if le power 0;
            return power part side;
          end;

          #battle_game.flashMessage "Gas Damage cancelled!";
          # debug_log "Gas damage reduced!";
          # debug_log "first is original power, after is power after reductions";
          # debug_log power;
          #We're only removing that percentage, not making the damage that percentage
          # div power itemResistSlotIndex;
          # sub itemResistSlotIndex 1;
          # mul power itemResistSlotIndex;

          # debug_log power;
          # debug_log power;
          # debug_log gasmaskProtectionValue;
          # debug_log "Above are power and gasmaskProtectionValue before anything";
          div gasmaskProtectionValue 50;
          div power gasmaskProtectionValue;
          # debug_log gasmaskProtectionValue;
          # debug_log power;
          # debug_log "Above are gasmaskProtectionValue after being divided by 50 and power after being divided by that";

          return power part side;

      - offset: 5
        code: |
          var int theOneAttackerTag;
          var int theOneHitTag;
          var int profficencyTag;
          var int applyChance;
          var ptre BattleItem unitLWeapon;
          var ptre BattleItem unitRWeapon;
          var ptre BattleItem ammoL;
          var ptre BattleItem ammoR;

          unit.getTag theOneHitTag Tag.UNIT_THE_ONE;

          attacker.getTag theOneAttackerTag Tag.UNIT_THE_ONE;
          attacker.getTag profficencyTag Tag.UNIT_THE_ONE_PATH_PROFFICIENCY;

          if neq theOneAttackerTag 1;
            return power part side;
          end;

          unit.getLeftHandWeapon unitLWeapon;
          unit.getRightHandWeapon unitRWeapon;
          unitLWeapon.getAmmoItem ammoL;
          unitRWeapon.getAmmoItem ammoR;
          battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
          if and eq battle_action BA_HIT ge applyChance profficencyTag;
            # debug_log "say goodbye to your ammo dumbass BA_HIT EDITION";
            battle_game.flashMessage "Agent was disarmed!";
            ammoL.setAmmoQuantity 0;
            ammoR.setAmmoQuantity 0;
            return power part side;
          end;

          return power part side;
      - offset: 6
        code: |
          var ptr RuleDamageType itemDamage;
          var ptr RuleItem damagingRuleItem;
          var int isDamageAOE;
          var int theOneAttackerTag;
          var int theOneHitTag;
          var int profficencyTag;
          var ptre BattleItem unitLWeapon;
          var ptre BattleItem unitRWeapon;
          var ptre BattleItem ammoL;
          var ptre BattleItem ammoR;
          var int applyChance;
          var int stunLevel;
          var int stunMax;
          var int isOnFire;
          var int totalWounds;
          var int tileShade;
          set isDamageAOE 0;

          unit.getTag theOneHitTag Tag.UNIT_THE_ONE;
          # debug_log weapon_item;
          # debug_log damaging_item;
          damaging_item.getRuleItem damagingRuleItem;
          # debug_log damagingRuleItem;
          damagingRuleItem.getDamageType itemDamage;
          # debug_log itemDamage;
          itemDamage.isAreaOfEffect isDamageAOE;
          # debug_log isDamageAOE;

          if neq theOneHitTag 1;
            return power part side;
          end;
          unit.disableIndicators;
          if eq isDamageAOE 1;
             # debug_log "Damage is AOE";
             return power part side;
          end;

          unit.getTag profficencyTag Tag.UNIT_THE_ONE_PATH_PROFFICIENCY;
          battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
          if ge applyChance profficencyTag;
            # debug_log "unit fails to dodge attack";
            return power part side;
          end;
          battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply

          # debug_log "Apply chance is";
          # debug_log applyChance;
          # debug_log "Below are stun level, stun max, on fire, total wounds and tileShade";
          unit.getStun stunLevel;
          unit.getStunMax stunMax;
          unit.getFire isOnFire;
          unit.getFatalwoundsTotal totalWounds;
          unit.getTileShade tileShade;
          # debug_log stunLevel;
          # debug_log stunMax;
          # debug_log isOnFire;
          # debug_log totalWounds;
          # debug_log tileShade;
          if ge isOnFire 1;
            # debug_log "Since unit is on fire we're reducing dodge chances by half";
            mul applyChance 2;
            # debug_log "new applychance: ";
            # debug_log applyChance;
          end;
          if le tileShade 6;
            # debug_log "Since unit is in the light we're reducing dodge chances by half";
            mul applyChance 2;
            # debug_log "new applychance: ";
            # debug_log applyChance;
          end;
          if and lt stunLevel applyChance eq profficencyTag 100; # dodges if stun level is below applyChance
            battle_game.flashMessage "The One Dodges!";
            add stunLevel 1;
            add totalWounds stunLevel;
            # debug_log "stunLevel after adding wounds and +1";
            # debug_log stunLevel;
            unit.setStun stunLevel;
            set power 0;
            return power part side;
          end;
          if and lt stunLevel applyChance eq profficencyTag 40; # dodges if stun level is below applyChance
            battle_game.flashMessage "Black Lotus Archwitch Dodges!";
            add stunLevel 2;
            add totalWounds stunLevel;
            # debug_log "stunLevel after adding wounds and +1";
            # debug_log stunLevel;
            unit.setStun stunLevel;
            set power 0;
            return power part side;
          end;
          if and lt stunLevel applyChance eq profficencyTag 20; # dodges if stun level is below applyChance
            battle_game.flashMessage "Black Lotus Knight Dodges!";
            add stunLevel 3;
            add totalWounds stunLevel;
            # debug_log "stunLevel after adding wounds and +1";
            # debug_log stunLevel;
            unit.setStun stunLevel;
            set power 0;
            return power part side;
          end;
          if le power 0;
            return power part side;
          end;

          # debug_log power;
          return power part side;
      - offset: 7 #Wieldable shield
        code: |
          var ptr RuleDamageType itemDamage;
          var ptr RuleItem damagingRuleItem;
          var ptre BattleItem leftHandItem;
          var ptre BattleItem rightHandItem;
          var ptre BattleItem shieldItem;
          var int isDamageAOE;
          var int leftTag;
          var int rightTag;
          var int temp;
          var int shieldArmor;
          var int shieldDurability;
          var int shieldFuse;
          var int shieldMultiplier;
          var int shieldMaxDmg;
          var int reducedPower;

          set isDamageAOE 0;
          set temp 0;

          unit.getLeftHandWeapon leftHandItem;
          unit.getRightHandWeapon rightHandItem;
          leftHandItem.getTag leftTag Tag.ITEM_IS_SHIELD;
          rightHandItem.getTag rightTag Tag.ITEM_IS_SHIELD;

          # debug_log "SHIELD DETECTION....";

          if and neq leftTag 1 neq rightTag 1;
            return power part side;
          else eq leftTag 1;
            set shieldItem leftHandItem;
          else eq rightTag 1;
            set shieldItem rightHandItem;
          end;
          # debug_log "SHIELD DETECTION SUCCESFUL!";

          shieldItem.getTag shieldArmor Tag.ITEM_SHIELD_ARMOR;
          shieldItem.getTag shieldDurability Tag.ITEM_SHIELD_DURABILITY;
          shieldItem.getTag shieldMultiplier Tag.ITEM_SHIELD_MULTIPLIER;
          shieldItem.getTag shieldMaxDmg Tag.ITEM_SHIELD_MAX_DMG;
          debug_log shieldArmor;
          debug_log shieldDurability;
          debug_log shieldMultiplier;
          debug_log "Above were shieldArmor, durability and multiplier";
          shieldItem.isFuseEnabled shieldFuse;

          if or eq damaging_type 0 eq isDamageAOE 1 le power 0 eq damaging_type 9;
            # debug_log "EXITING BECAUSE DAMAGING TYPE IS EITHER 0, DAMAGE WAS AOE OR POWER WAS 0 OR LESS! ";
            return power part side;
          end;

          if le shieldDurability 0;
            battle_game.flashMessage "Shield is too badly damaged to protect!";
            shieldItem.setFuseTimer -1;
            debug_log "SHIELD DURABILITY IS 0 OR LESS!";
            return power part side;
          end;

          debug_log "SHIELD DURABILITY WAS MORE THAN 0!";
          damaging_item.getRuleItem damagingRuleItem;
          damagingRuleItem.getDamageType itemDamage;
          itemDamage.isAreaOfEffect isDamageAOE;

          if or eq side SIDE_REAR eq side SIDE_UNDER;
            return power part side;
          end;

          if eq damaging_type 0; #wont go through
            shieldItem.getTag temp Tag.ITEM_SHIELD_SPECIAL_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 1;
            shieldItem.getTag temp Tag.ITEM_SHIELD_KINETIC_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 2;
            shieldItem.getTag temp Tag.ITEM_SHIELD_INCENDIARY_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 3;
            shieldItem.getTag temp Tag.ITEM_SHIELD_CONCUSSIVE_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 4;
            shieldItem.getTag temp Tag.ITEM_SHIELD_LASER_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 5;
            shieldItem.getTag temp Tag.ITEM_SHIELD_PLASMA_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 6;
            shieldItem.getTag temp Tag.ITEM_SHIELD_STUN_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 7;
            shieldItem.getTag temp Tag.ITEM_SHIELD_CUTTING_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 8;
            shieldItem.getTag temp Tag.ITEM_SHIELD_SPECIAL_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 9; #Wont go through
            shieldItem.getTag temp Tag.ITEM_SHIELD_CHOKING_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 10;
            shieldItem.getTag temp Tag.ITEM_SHIELD_EMP_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 11;
            shieldItem.getTag temp Tag.ITEM_SHIELD_ELECTRIC_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 12;
            shieldItem.getTag temp Tag.ITEM_SHIELD_PSI_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 13;
            shieldItem.getTag temp Tag.ITEM_SHIELD_WARP_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 14;
            shieldItem.getTag temp Tag.ITEM_SHIELD_ANTI_E115_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;

          else eq damaging_type 15;
            shieldItem.getTag temp Tag.ITEM_SHIELD_BIO_RT;
            if eq temp 0; #this ensures all values are by default 100 instead of 0
                set temp 100;
            end;
          end;

          debug_log "Resistance value is  and power are ";
          debug_log temp;
          debug_log power;
          set reducedPower power;
          muldiv reducedPower temp 100;
          debug_log "Power after multiplication";
          debug_log reducedPower;
          set temp 0;

          if or eq side SIDE_LEFT eq side SIDE_RIGHT;
            battle_game.randomRange temp 1 100;

            if eq shieldFuse 1;
              div shieldMultiplier 10;
              add temp shieldMultiplier;
            end;

            debug_log temp;
            if lt temp 25;
              return power part side;
            end;
            battle_game.flashMessage "Shield barely blocks some damage from the side!";
            div shieldArmor 2;
          else eq side SIDE_FRONT;
            debug_log "shieldMultiplier after hitting the front!";
            debug_log shieldMultiplier;
            div shieldMultiplier 100;
            mul shieldArmor shieldMultiplier;
          end;

          debug_log "Power is equal to";
          debug_log power;
          debug_log "Shield armor is eq to";
          debug_log shieldArmor;
          sub power shieldArmor;
          debug_log "Power after damage reduction is equal to";
          debug_log power;
          if le power 0;
            set power 0;
          end;
          sub shieldDurability power;
          if le shieldDurability 0;
            shieldItem.setFuseTimer -1;
            shieldItem.setTag Tag.ITEM_SHIELD_DURABILITY 0;
            battle_game.flashMessage "Shield blocks some damage but shatters!";
            return power part side;
          end;
          battle_game.flashMessage "Shield blocks some damage!";
          shieldItem.getTag temp Tag.ITEM_SHIELD_DURABILITY;
          set power reducedPower;
          debug_log temp;
          debug_log "Durability before damage";
          shieldItem.setTag Tag.ITEM_SHIELD_DURABILITY shieldDurability;
          debug_log "Durability after";
          debug_log shieldDurability;

          return power part side;
    selectItemSprite:
      - offset: 1 # Select weapon bigSprite based on ammo item
        code: |
          var ptr BattleItem ammoItem;
          var ptr RuleItem weaponRuleset;
          var ptr RuleItem ammoRuleset;
          var int doResprite;
          var int doEmptyResprite;
          var int newSprite;
          var int modOffset;

          if eq blit_part blit_item_big;
            item.getRuleItem weaponRuleset;
            weaponRuleset.getTag doResprite Tag.ALLOW_AMMO_TO_RESPRITE;
            item.getAmmoItem ammoItem;
            set doEmptyResprite 0;
            if eq ammoItem null;
              set doEmptyResprite 1;
            end;

            if and eq doResprite 1 eq doEmptyResprite 1; #Empty version
              # debug_log "I managed to get to doresprite 1 and emptyresprite 1 !";
              weaponRuleset.getTag newSprite Tag.NEW_BIGOB_FOR_WEAPON;
              if neq newSprite 0; #Empty version
                # debug_log "I managed to get newsprite not equal 0!";
                weaponRuleset.getTag sprite_index Tag.NEW_BIGOB_FOR_WEAPON;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetBigobs sprite_index modOffset;
                return sprite_index;
              end;

            else and eq doResprite 1 eq doEmptyResprite 0; #Non-empty version
              item.getAmmoItem ammoItem;
              ammoItem.getRuleItem ammoRuleset;
              ammoRuleset.getTag newSprite Tag.NEW_BIGOB_FOR_WEAPON;
              if neq newSprite 0; #Non-empty version
                ammoRuleset.getTag sprite_index Tag.NEW_BIGOB_FOR_WEAPON;
                ammoRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetBigobs sprite_index modOffset;
                return sprite_index;
              end;

            end;
          end;
          return sprite_index;
      - offset: 1.5 # Select shield bigSprite based on status
        code: |
          var ptr RuleItem weaponRuleset;
          var int primedResprite; #Primed
          var int brokenResprite; #Broken
          var int newSprite;
          var int modOffset;
          var int shieldTag;
          var int primedState;
          var int brokenState;

          if or eq blit_part blit_item_big;
            item.getRuleItem weaponRuleset;
            weaponRuleset.getTag shieldTag Tag.ITEM_IS_SHIELD;

            if eq shieldTag 0;
              return sprite_index;
            end;

           item.isFuseEnabled primedState;
           item.getTag brokenState Tag.ITEM_SHIELD_DURABILITY;

           # debug_log "Shiield durability was";
           # debug_log brokenState;

           if neq primedState 0;
             set primedResprite 1;
           end;

           if le brokenState 0;
             set brokenResprite 1;
             set primedResprite 0;
             # debug_log "Broken Resprite activated!";
           end;

           if and eq primedResprite 0 eq brokenResprite 0;
             return sprite_index;
           end;

            if eq primedResprite 1; #Primed version
              # debug_log "I managed to get to primedResprite 1!";
              weaponRuleset.getTag newSprite Tag.BIGOB_FOR_PRIMED;
              if neq newSprite 0; #Empty version
                # debug_log "I managed to get newsprite not equal 0!";
                weaponRuleset.getTag sprite_index Tag.BIGOB_FOR_PRIMED;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetBigobs sprite_index modOffset;
                return sprite_index;
              end;
            end;

            if eq brokenResprite 1; #Broken version
              # debug_log "I managed to get to brokenResprite 1!";
              weaponRuleset.getTag newSprite Tag.BIGOB_FOR_BROKEN;
              if neq newSprite 0; #Empty version
                # debug_log "I managed to get newsprite not equal 0!";
                weaponRuleset.getTag sprite_index Tag.BIGOB_FOR_BROKEN;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetBigobs sprite_index modOffset;
                return sprite_index;
              end;

            end;
          end;
          return sprite_index;
      - offset: 2 # Select weapon floorSprite based on ammo item
        code: |
          var ptr BattleItem ammoItem;
          var ptr RuleItem weaponRuleset;
          var ptr RuleItem ammoRuleset;
          var int doResprite;
          var int doEmptyResprite;
          var int newSprite;
          var int modOffset;

          if eq blit_part blit_item_floor;
            item.getRuleItem weaponRuleset;
            weaponRuleset.getTag doResprite Tag.ALLOW_AMMO_TO_RESPRITE;
            item.getAmmoItem ammoItem;
            set doEmptyResprite 0;
            if eq ammoItem null;
              set doEmptyResprite 1;
            end;

            if and eq doResprite 1 eq doEmptyResprite 1; #Empty version
              debug_log "I managed to get to doresprite 1 and emptyresprite 1 !";
              weaponRuleset.getTag newSprite Tag.NEW_FLOOROB_FOR_WEAPON;
              if neq newSprite 0; #Empty version
                debug_log "I managed to get newsprite not equal 0!";
                weaponRuleset.getTag sprite_index Tag.NEW_FLOOROB_FOR_WEAPON;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetFloorob sprite_index modOffset;
                return sprite_index;
              end;

            else and eq doResprite 1 eq doEmptyResprite 0; #Non-empty version
              item.getAmmoItem ammoItem;
              ammoItem.getRuleItem ammoRuleset;
              ammoRuleset.getTag newSprite Tag.NEW_FLOOROB_FOR_WEAPON;
              if neq newSprite 0; #Non-empty version
                ammoRuleset.getTag sprite_index Tag.NEW_FLOOROB_FOR_WEAPON;
                ammoRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetFloorob sprite_index modOffset;
                return sprite_index;
              end;

            end;
          end;
          return sprite_index;
      - offset: 2.5 # Select shield floorob based on status
        code: |
          var ptr RuleItem weaponRuleset;
          var int primedResprite; #Primed
          var int brokenResprite; #Broken
          var int newSprite;
          var int modOffset;
          var int shieldTag;
          var int brokenState;

          if eq blit_part blit_item_floor;
            item.getRuleItem weaponRuleset;
            weaponRuleset.getTag shieldTag Tag.ITEM_IS_SHIELD;

            if eq shieldTag 0;
              return sprite_index;
            end;

           item.getTag brokenState Tag.ITEM_SHIELD_DURABILITY;

           # debug_log "Shiield durability was";
           # debug_log brokenState;


           if le brokenState 0;
             set brokenResprite 1;
             # debug_log "Broken Resprite activated!";
           end;

           if eq brokenResprite 0;
             return sprite_index;
           end;

            if eq brokenResprite 1; #Broken version
              debug_log "I managed to get to brokenResprite 1!";
              weaponRuleset.getTag newSprite Tag.FLOOROB_FOR_BROKEN;
              if neq newSprite 0;
                debug_log "I managed to get newsprite not equal 0!";
                weaponRuleset.getTag sprite_index Tag.FLOOROB_FOR_BROKEN;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetFloorob sprite_index modOffset;
                return sprite_index;
              end;

            end;
          end;
          return sprite_index;
      - offset: 3 # Select weapon handSprite based on ammo item
        code: |
          var ptr BattleItem ammoItem;
          var ptr RuleItem weaponRuleset;
          var ptr RuleItem ammoRuleset;
          var int doResprite;
          var int doEmptyResprite;
          var int newSprite;
          var int modOffset;

          if or eq blit_part blit_item_lefthand eq blit_part blit_item_righthand;
            item.getRuleItem weaponRuleset;
            weaponRuleset.getTag doResprite Tag.ALLOW_AMMO_TO_RESPRITE;
            item.getAmmoItem ammoItem;
            set doEmptyResprite 0;
            if eq ammoItem null;
              set doEmptyResprite 1;
            end;

            if and eq doResprite 1 eq doEmptyResprite 1; #Empty version
              debug_log "I managed to get to doresprite 1 and emptyresprite 1 !";
              weaponRuleset.getTag newSprite Tag.NEW_HANDOB_FOR_WEAPON;
              if neq newSprite 0; #Empty version
                add newSprite sprite_offset;
                set sprite_index newSprite;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetHandob sprite_index modOffset;
                return sprite_index;
              end;

            else and eq doResprite 1 eq doEmptyResprite 0; #Non-empty version
              item.getAmmoItem ammoItem;
              ammoItem.getRuleItem ammoRuleset;
              ammoRuleset.getTag newSprite Tag.NEW_HANDOB_FOR_WEAPON;
              if neq newSprite 0; #Non-empty version
                add newSprite sprite_offset;
                set sprite_index newSprite;
                ammoRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetHandob sprite_index modOffset;
                return sprite_index;
              end;

            end;
          end;
          return sprite_index;
      - offset: 3.5 # Select shield handSprite based on status
        code: |
          var ptr RuleItem weaponRuleset;
          var int primedResprite; #Primed
          var int brokenResprite; #Broken
          var int newSprite;
          var int modOffset;
          var int shieldTag;
          var int primedState;
          var int brokenState;

          if or eq blit_part blit_item_lefthand eq blit_part blit_item_righthand;
            item.getRuleItem weaponRuleset;
            weaponRuleset.getTag shieldTag Tag.ITEM_IS_SHIELD;

            if eq shieldTag 0;
              return sprite_index;
            end;

           item.isFuseEnabled primedState;
           item.getTag brokenState Tag.ITEM_SHIELD_DURABILITY;

           # debug_log "Shiield durability was";
           # debug_log brokenState;

           if neq primedState 0;
             set primedResprite 1;
           end;

           if le brokenState 0;
             set brokenResprite 1;
             set primedResprite 0;
             # debug_log "Broken Resprite activated!";
           end;

           if and eq primedResprite 0 eq brokenResprite 0;
             return sprite_index;
           end;

            if eq primedResprite 1; #Primed version
              # debug_log "I managed to get to primedResprite 1!";
              weaponRuleset.getTag newSprite Tag.HANDOB_FOR_PRIMED;
              if neq newSprite 0; #Empty version
                add newSprite sprite_offset;
                set sprite_index newSprite;
                # debug_log "I managed to get newsprite not equal 0!";
                # weaponRuleset.getTag sprite_index Tag.HANDOB_FOR_PRIMED;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetHandob sprite_index modOffset;
                return sprite_index;
              end;
            end;

            if eq brokenResprite 1; #Broken version
              # debug_log "I managed to get to brokenResprite 1!";
              weaponRuleset.getTag newSprite Tag.HANDOB_FOR_BROKEN;
              if neq newSprite 0; #Empty version
                add newSprite sprite_offset;
                set sprite_index newSprite;
                # debug_log "I managed to get newsprite not equal 0!";
                # weaponRuleset.getTag sprite_index Tag.HANDOB_FOR_BROKEN;
                weaponRuleset.getTag modOffset Tag.CURRENT_MOD_OFFSET;
                rules.getSpriteOffsetHandob sprite_index modOffset;
                return sprite_index;
              end;

            end;
          end;
          return sprite_index;
    recolorUnitSprite:
      - offset: 0.1 #Handles periodic recolors due to daze
        code: |
          var int frame;
          var int frameLength;
          var int teargassedTag;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;
          var ptr RuleArmor armorRuleset;

          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.LAST_HIT_FRAME;
          set frameLength 6;
          set recolorPeriod 36;

          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              return new_pixel;
            end;

          end;

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          unit.getTag temp Tag.TTAG_ISTEARGASSED;

          if and neq temp 0 lt frame frameLength;
            #set temp anim_frame;
            wavegen_tri frame 12 12 12;
            mul frame -1;
            add frame 6; #8;
            get_shade newShade new_pixel;
            sub newShade frame;

            if gt newShade 4;
              set_shade new_pixel newShade;
              else;
              set_shade new_pixel 4;
            end;


          end;

          return new_pixel;
      - offset: 10
        code: |
          var int frame;
          var int frameLength;
          var int color;
          var int newShade;
          var int temp;

          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              # Check shade, add some darkening decay, but don't recolor if it'd go too dark
              get_shade newShade new_pixel;
              mul temp 4;
              sub newShade temp;
              if or lt newShade 4 gt newShade 15;
                return new_pixel;
              end;

              unit.getTag color Tag.UNIT_RECOLOR_COLOR;
              set_color new_pixel color;
              set_shade new_pixel newShade;
            end;
          end;

          return new_pixel;
    skillUseUnit:
      - offset: 0.1 #skill test only triggers when skill is used
        code: |
          var int test;

          #debug_log "SKILL USE UNIT!";
          return;
    createItem:
      - offset: 0.1 #testing
        code: |
          var int lightValue;
          var int lightPower;
          var int lightDuration;
          var int tileX;
          var int tileY;
          var int tileZ;
          var ptr Tile tileToFind;

          #debug_log "I AM HERE createitem";
          #debug_log tileX;
          #tileToFind.getPosition.getX tileX;
          #debug_log tileX;
          #debug_log "Above was tileX";
          #tileToFind.getPosition.getY tileY;
          #tileToFind.getPosition.getZ tileZ;
          #battle_game.getTile tileToFind tileX tileY tileZ;
          #debug_log tileX;
          #debug_log tileY;
          #debug_log tileZ;
          #debug_log "CreateItem script";

          return;
      - offset: 0.1 #testing
        code: |
          var int shieldTag;
          var int shieldArmorTag;
          var int shieldDurabilityTag;
          var int shieldAimingPenaltyTag;
          var int shieldMultiplierTag;
          var int shieldDamageResistTag;
          var int shieldMaxDmgTag;
          var ptr RuleItem ruleItem;
          var int temp;

          item.getRuleItem ruleItem;
          ruleItem.getTag shieldTag Tag.ITEM_IS_SHIELD;

          if eq shieldTag 1;
            ruleItem.getTag shieldArmorTag Tag.SHIELD_ARMOR;
            ruleItem.getTag shieldDurabilityTag Tag.SHIELD_DURABILITY;
            ruleItem.getTag shieldAimingPenaltyTag Tag.SHIELD_AIMING_PENALTY;
            ruleItem.getTag shieldMultiplierTag Tag.SHIELD_MULTIPLIER;
            ruleItem.getTag shieldMaxDmgTag Tag.SHIELD_MAX_DMG;
            item.setTag Tag.ITEM_SHIELD_ARMOR shieldArmorTag;
            item.setTag Tag.ITEM_SHIELD_DURABILITY shieldDurabilityTag;
            item.setTag Tag.ITEM_SHIELD_AIMING_PENALTY shieldAimingPenaltyTag;
            item.setTag Tag.ITEM_SHIELD_MULTIPLIER shieldMultiplierTag;
            item.setTag Tag.ITEM_SHIELD_MAX_DMG shieldMaxDmgTag;

            ruleItem.getTag temp Tag.SHIELD_SPECIAL_RT; #0 SPECIAL
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_SPECIAL_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_KINETIC_RT; #1 KINETIC
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_KINETIC_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_INCENDIARY_RT; #2 INCENDIARY
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_INCENDIARY_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_INCENDIARY_RT; #3 INCENDIARY
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_INCENDIARY_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_LASER_RT; #4 LASER
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_LASER_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_PLASMA_RT; #5 PLASMA
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_PLASMA_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_STUN_RT; #6 STUN
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_STUN_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_CUTTING_RT; #7 CUTTING
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_CUTTING_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_CHEMICAL_RT; #8 CHEMICAL
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_CHEMICAL_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_CHOKING_RT; #9 CHOKING
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_CHOKING_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_EMP_RT; #10 EMP
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_EMP_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_ELECTRIC_RT; #11 ELECTRIC
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_ELECTRIC_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_PSI_RT; #12 PSI
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_PSI_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_WARP_RT; #13 WARP
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_WARP_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_ANTI_E115_RT; #14 ANTI E-115
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_ANTI_E115_RT temp;
            end;

            ruleItem.getTag temp Tag.SHIELD_BIO_RT; #15 BIO
            if neq temp 0;
              item.setTag Tag.ITEM_SHIELD_BIO_RT temp;
            end;

          end;

          return;
    visibilityUnit:
      - offset: 1 #testingVisibilityUnit
        code: |
          var ptr RuleArmor armorRuleset;
          var int observerFaction;
          var int targetFaction;
          var int observerHostageTag;
          var int observerTerroristTag;
          var int observerInvisibleTag;
          var int observerIgnoreTag;
          var int targetHostageTag;
          var int targetTerroristTag;
          var int targetInvisibleTag;
          var int targetIgnoreTag;
          var int immunityTag;
          var int observerBlindTag;
          var int targetBlindTag;

          observer_unit.getFaction observerFaction;
          target_unit.getFaction targetFaction;
          observer_unit.getTag observerTerroristTag Tag.UNIT_IS_TERRORIST;
          observer_unit.getTag observerInvisibleTag Tag.UNIT_IS_INVISIBLE;
          observer_unit.getTag observerIgnoreTag Tag.UNIT_IS_IGNORED;
          observer_unit.getTag observerHostageTag Tag.UNIT_IS_HOSTAGE;
          observer_unit.getTag observerBlindTag Tag.UNIT_IS_BLIND;
          target_unit.getTag targetTerroristTag Tag.UNIT_IS_TERRORIST;
          target_unit.getTag targetInvisibleTag Tag.UNIT_IS_INVISIBLE;
          target_unit.getTag targetIgnoreTag Tag.UNIT_IS_IGNORED;
          target_unit.getTag targetHostageTag Tag.UNIT_IS_HOSTAGE;
          target_unit.getTag immunityTag Tag.UNIT_IMMUNITY_TIME;
          target_unit.getTag targetBlindTag Tag.UNIT_IS_BLIND;
          if and eq observerFaction 0 eq observerBlindTag 1; #Refine this bit please, it could be worked into a "turret tag" instead, see if this doesnt break any other logic!
            set current_visibility 0;
            return current_visibility visibility_mode;
          end;
          if and eq observerFaction 1 eq targetBlindTag 1;
            set current_visibility 0;
            return current_visibility visibility_mode;
          end;
          # debug_log observerFaction;
          # debug_log targetFaction;
          if eq observerFaction 0;
            #If observer is a player we're gonna see if target is an enemy AND has invisiible and ignore tags (A flare or proximity unit probably)
            if and eq targetFaction 1 eq targetInvisibleTag 1 eq targetIgnoreTag 1;
              # debug_log "Observer (Player) Target (INVI: true, IGNORE: true)";
              set current_visibility 0;
              return current_visibility visibility_mode;
            end;
          end;

          if eq observerFaction 1;
            # debug_log "Unit is Enemy faction";
            if and eq observerTerroristTag 0 eq observerInvisibleTag 0 eq observerIgnoreTag 0;
              #If observer is not as terrorist, and doesnt have invisible or ignore tags (Flare/Proximity) then we exit normally
              return current_visibility visibility_mode;
            end;
            # if eq terroristTag 1;
              # debug_log "Unit is a terrorist!";
            # end;
            # if eq ignoreTag 1;
              # debug_log "Unit must be ignored!";
            # end;
            # if eq invisibleTag 1;
              # debug_log "Unit is invisible!";
            # end;
            if eq targetFaction 0;
            #If the target is a player and observer unit is invisible (Flares, Proximities) they ignore the player
              if and eq observerInvisibleTag 1 eq observerIgnoreTag 1;
                # debug_log "Observer (INVI: true, IGNORE: true) Target (Player)";
                set current_visibility 0;
                return current_visibility visibility_mode;
              end;
            end;
            if eq targetFaction 2;
              # debug_log "Target unit is Neutral faction";
              target_unit.getTag targetHostageTag Tag.UNIT_IS_HOSTAGE;
              if and eq targetHostageTag 1 gt immunityTag 0;
                # if target unit is a hostage then we ignore him
                # debug_log "This unit is both a hostage and has an immunity tag of:";
                # debug_log immunityTag;
                set current_visibility 0;
                # debug_log "unit seen WAS tagged as hostage, unit is invisible to enemy";
                return current_visibility visibility_mode;
              else;
                # debug_log "Unit was not hostage, ignoring, prepare to die lol";
                return current_visibility visibility_mode;
              end;

            else;
              # debug_log "Target is not Neutral faction";
              set current_visibility default_visibility;
            end;
          end;

          return current_visibility visibility_mode;